# 修改studies表格顏色和顯示方式
_Exported on 11/1/2025 at 00:33:16 GMT+8 from Cursor (2.0.43)_

---

**User**

@Studies.css @Studies.jsx 顯示studies的表格背景改成都不要有顏色 然後Title 改成深藍黑色， Journal, Authors, PubMed 這三個資訊改成都不要折疊起來 全部顯示出來就好 PubMed用深綠色

---

**Cursor**


檢視目前的程式碼結構，準備進行以下修改：
1. 移除表格行的背景色（odd/even）
2. 將 Title 設為深藍黑色
3. 移除折疊功能，讓 Journal、Authors、PubMed 始終顯示
4. 將 PubMed 設為深綠色


進行以下修改：
1. 移除表格行的背景色
2. Title 設為深藍黑色
3. 移除折疊功能，讓 Journal、Authors、PubMed 始終顯示
4. PubMed 設為深綠色


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--clickable {
  cursor: pointer;
}

.studies__tr--clickable:hover {
  background: rgba(0, 0, 0, 0.05) !important;
}

.studies__tr--detail {
  background: rgba(0, 0, 0, 0.02) !important;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: rgba(0, 0, 0, 0.02);
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--fg-dark);
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: var(--muted);
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: rgba(0, 0, 0, 0.02);
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--fg-dark);
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: var(--muted);
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--fg-dark);
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: var(--muted);
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
  color: #1a1a2e;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: var(--fg-dark);
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: var(--muted);
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
  color: #1a1a2e;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header">
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const isExpanded = expandedRows.has(globalIndex)
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd',
                          'studies__tr--clickable'
                        )}
                        onClick={() => toggleRow(globalIndex)}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      {isExpanded && (
                        <tr 
                          key={`detail-${globalIndex}`}
                          className={classNames(
                            'studies__tr',
                            'studies__tr--detail',
                            i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                          )}
                        >
                          <td colSpan={2} className="studies__td studies__td--detail">
                            <div className="studies__detail-content">
                              <div className="studies__detail-row">
                                <span className="studies__detail-label">Journal:</span>
                                <span className="studies__detail-value">{r.journal || '—'}</span>
                              </div>
                              <div className="studies__detail-row">
                                <span className="studies__detail-label">Authors:</span>
                                <span className="studies__detail-value">{r.authors || '—'}</span>
                              </div>
                              <div className="studies__detail-row">
                                <span className="studies__detail-label">PubMed:</span>
                                {pubmedUrl ? (
                                  <a
                                    href={pubmedUrl}
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="studies__pubmed-link"
                                    title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                    onClick={(e) => e.stopPropagation()}
                                  >
                                    <span>{r.study_id || r.id || r.pubmed_id}</span>
                                    <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                      <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                    </svg>
                                  </a>
                                ) : (
                                  <span className="studies__no-pubmed">—</span>
                                )}
                              </div>
                            </div>
                          </td>
                        </tr>
                      )}
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header">
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

移除 CSS 中不再需要的 clickable 樣式：


檢查是否有 lint 錯誤：


檢查 CSS 檔案，確認所有變更已正確應用：


已完成以下修改：

## 修改摘要

1. **移除表格背景顏色**：
   - 將 `.studies__tr--odd` 和 `.studies__tr--even` 的背景設為 `transparent`
   - 將 `.studies__tr--detail` 的背景設為 `transparent`
   - 將 `.studies__td--detail` 的背景設為 `transparent`

2. **Title 改為深藍黑色**：
   - 在 `.studies__title-cell` 加入 `color: #1a1a2e`

3. **移除折疊功能，讓所有資訊始終顯示**：
   - 移除 `expandedRows` state 和相關的 `toggleRow` 函數
   - 移除行點擊事件和 `studies__tr--clickable` class
   - 移除 `isExpanded` 條件判斷，讓 detail row 始終顯示
   - 移除 `onClick={(e) => e.stopPropagation()}`

4. **PubMed 改為深綠色**：
   - 將 `.studies__pubmed-link` 顏色改為 `#006400`
   - hover 狀態改為 `#228B22`

現在表格會：
- 無背景顏色（透明）
- Title 顯示為深藍黑色
- Journal、Authors、PubMed 資訊始終顯示（不再需要點擊展開）
- PubMed 連結顯示為深綠色

所有修改已完成，無 lint 錯誤。

---

**User**

Title改成#D94600這個色號看看



---

**Cursor**


將 Title 顏色改為 `#D94600`。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
  color: #D94600;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已將 Title 顏色改為 `#D94600`（橙紅色）。修改已完成，無 lint 錯誤。

---

**User**

改成#004B97	試試看

---

**Cursor**


將 Title 顏色改為 `#004B97`。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 15px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已將 Title 顏色改為 `#004B97`（藍色）。修改完成，無 lint 錯誤。

---

**User**

@Studies.css @Studies.jsx 按下下一頁的按鈕時 畫面要往上跳轉到搜尋結果的最高點

---

**Cursor**


檢視目前的程式碼結構，準備新增按下分頁按鈕時自動滾動到搜尋結果頂部的功能。


新增滾動功能：當頁碼改變時自動滾動到搜尋結果頂部。


```javascriptreact
import { useEffect, useMemo, useState, useRef } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')
  const tableTopRef = useRef(null)

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  // Scroll to top when page changes
  const scrollToTop = () => {
    if (tableTopRef.current) {
      tableTopRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' })
    }
  }

  // Handle page change with scroll
  const handlePageChange = (newPage) => {
    setPage(newPage)
    // Use setTimeout to ensure DOM has updated before scrolling
    setTimeout(() => {
      scrollToTop()
    }, 100)
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header">
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState, useRef } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')
  const tableTopRef = useRef(null)

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  // Scroll to top when page changes
  const scrollToTop = () => {
    if (tableTopRef.current) {
      tableTopRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' })
    }
  }

  // Handle page change with scroll
  const handlePageChange = (newPage) => {
    setPage(newPage)
    // Use setTimeout to ensure DOM has updated before scrolling
    setTimeout(() => {
      scrollToTop()
    }, 100)
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      handlePageChange(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header">
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState, useRef } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')
  const tableTopRef = useRef(null)

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  // Scroll to top when page changes
  const scrollToTop = () => {
    if (tableTopRef.current) {
      tableTopRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' })
    }
  }

  // Handle page change with scroll
  const handlePageChange = (newPage) => {
    setPage(newPage)
    // Use setTimeout to ensure DOM has updated before scrolling
    setTimeout(() => {
      scrollToTop()
    }, 100)
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      handlePageChange(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header" ref={tableTopRef}>
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(Math.max(1, page - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(Math.min(totalPages, page + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => setPage(p => Math.max(1, p - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(p => Math.min(totalPages, p + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => setPage(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState, useRef } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')
  const tableTopRef = useRef(null)

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  // Scroll to top when page changes
  const scrollToTop = () => {
    if (tableTopRef.current) {
      tableTopRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' })
    }
  }

  // Handle page change with scroll
  const handlePageChange = (newPage) => {
    setPage(newPage)
    // Use setTimeout to ensure DOM has updated before scrolling
    setTimeout(() => {
      scrollToTop()
    }, 100)
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      handlePageChange(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header" ref={tableTopRef}>
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(Math.max(1, page - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(Math.min(totalPages, page + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
                <th className="studies__th studies__th--no-sort">
                  Title
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(Math.max(1, page - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(Math.min(totalPages, page + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

檢查是否有 lint 錯誤：


已新增滾動功能。修改如下：

## 修改摘要

1. **導入 `useRef`**：從 React 導入 `useRef` hook

2. **創建 ref**：添加 `tableTopRef` 用於引用搜尋結果的頂部元素（header）

3. **滾動函數**：
   - `scrollToTop()`：使用 `scrollIntoView` 平滑滾動到頂部
   - `handlePageChange(newPage)`：改變頁碼並觸發滾動

4. **更新所有分頁按鈕**：
   - 上方和下方的分頁按鈕（`<<`, `<`, `>`, `>>`）都改為使用 `handlePageChange`
   - 頁面輸入框（Enter 或 blur）也會觸發滾動

現在當用戶點擊任何分頁按鈕（包括通過輸入框跳轉頁面）時，頁面會平滑滾動到搜尋結果的頂部（header 區域）。

修改完成，無 lint 錯誤。

---

**User**

@Studies.css @Studies.jsx title的字體再大一點

---

**Cursor**


查看目前的 CSS，準備將 title 字體調大。


將 title 字體從 15px 調大。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 20px;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已將 title 字體大小從 `15px` 調整為 `17px`。修改完成，無 lint 錯誤。

---

**User**

Journal, Authors, PubMed這三文字跟他們的結果要對齊title的左邊

---

**Cursor**


查看目前 CSS，調整 Journal、Authors、PubMed 及其值與 title 左對齊。


移除 `.studies__detail-content` 的 `padding-left`，讓 Journal、Authors、PubMed 對齊 title 的左邊。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

檢查 lint 錯誤：


已調整 CSS，讓 Journal、Authors、PubMed 及其值與 title 左對齊。

## 修改摘要

1. **移除左邊距**：將 `.studies__detail-content` 的 `padding-left` 從 `20px` 改為 `0`
2. **統一 padding**：確保 `.studies__td--detail` 的左右 padding 為 `12px`，與 title 的左右 padding 一致

現在 Journal、Authors、PubMed 及其值會與 title 的左邊對齊。修改完成，無 lint 錯誤。

---

**User**

我的意思是開頭的位置要跟title的t一樣

---

**Cursor**


檢查 title 與 detail 的 padding，確保 Journal、Authors、PubMed 的開頭與 title 的第一個字母對齊。


統一 title 與 detail 的 padding，確保文字起始位置對齊。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding: 12px 12px 12px 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

檢查 title 的 padding，確保兩者一致：


確保 detail 的左邊 padding 與 title 一致（都是 12px），並移除 detail-content 的任何額外間距：


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 12px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已調整 CSS，確保 Journal、Authors、PubMed 的開頭與 title 的第一個字母對齊：

1. **明確設定 detail 的 padding**：左邊 padding 設為 `12px`，與 title 一致（title 繼承自 `.studies__td`，左邊 padding 也是 `12px`）
2. **移除額外間距**：在 `.studies__detail-content` 中設定 `padding-left: 0` 和 `margin-left: 0`，確保沒有額外偏移

現在 Journal、Authors、PubMed 的開頭應與 title 的第一個字母對齊。修改完成，無 lint 錯誤。

---

**User**

這看起來還沒對齊

---

**Cursor**


檢視目前的結構，確認對齊問題：


調整 detail 的 `padding-left`，讓它對齊 Title：Year 欄位寬度為 60px，加上 Year 的右側 padding 12px，因此 detail 的 `padding-left` 設為 72px。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 72px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

調整 detail 的 `padding-left`：Year 欄位寬度（60px）+ Year 右側 padding（12px）+ Title 左側 padding（12px）= 84px，讓 detail 內容與 Title 第一個字母對齊。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 84px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

調整 detail 的 `padding-left`：Year 欄位總寬度（84px）+ Title 左側 padding（12px）= 96px，讓 detail 內容與 Title 第一個字母對齊。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: 1px solid var(--border);
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 96px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已將 detail 的 `padding-left` 設為 `96px`。計算方式：

- **Year 欄位**：寬度 60px + 左邊 padding 12px + 右邊 padding 12px = 84px
- **Title 欄位**：左邊 padding 12px
- **Detail 的 padding-left**：84px + 12px = 96px

這樣 Journal、Authors、PubMed 的開頭會與 Title 的第一個字母對齊。修改完成，無 lint 錯誤。請檢查是否符合預期。

---

**User**

@Studies.css @Studies.jsx 每個搜尋結果之間的橫線可以刪除 然後year, title 的底下也不要有顏色

---

**Cursor**


檢查目前的 CSS，移除搜尋結果之間的橫線，並移除 Year 和 Title 下方的邊框。


移除搜尋結果之間的橫線，並移除 Year 和 Title 下方的邊框。


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: 2px solid var(--border);
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: none;
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 96px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: var(--bg-light);
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: none;
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: none;
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 96px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已完成以下修改：

1. **移除搜尋結果之間的橫線**：將 `.studies__td` 的 `border-bottom` 從 `1px solid var(--border)` 改為 `none`
2. **移除 Year 和 Title 底下的邊框**：將 `.studies__th` 的 `border-bottom` 從 `2px solid var(--border)` 改為 `none`

現在表格不再有橫線分隔，Year 和 Title 標題下方也沒有邊框。修改完成，無 lint 錯誤。

---

**User**

@Studies.css @Studies.jsx 現在來處理第一row 把title這個文字刪除 只留下year這個文字 底下不要有灰色

---

**Cursor**


檢查目前的程式碼結構，準備修改 header 行：


移除 Title 欄位，並移除 header 的背景色：


```javascriptreact
import { useEffect, useMemo, useState, useRef } from 'react'
import './Studies.css'
import { PageSizeSelector } from './PageSizeSelector'
import { YearFilter } from './YearFilter'

function classNames (...xs) { return xs.filter(Boolean).join(' ') }

export function Studies ({ query }) {
  const [rows, setRows] = useState([])
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [sortKey, setSortKey] = useState('year')
  const [sortDir, setSortDir] = useState('desc')
  const [page, setPage] = useState(1)
  const [pageSize, setPageSize] = useState(20)
  const [selectedYears, setSelectedYears] = useState([])
  const [pageInput, setPageInput] = useState('1')
  const tableTopRef = useRef(null)

  // Helper function to get PubMed URL
  const getPubMedUrl = (studyId) => {
    if (!studyId) return null
    const id = String(studyId).trim()
    if (!id || !/^\d+$/.test(id)) return null
    return `https://pubmed.ncbi.nlm.nih.gov/${id}/`
  }

  // Scroll to top when page changes
  const scrollToTop = () => {
    if (tableTopRef.current) {
      tableTopRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' })
    }
  }

  // Handle page change with scroll
  const handlePageChange = (newPage) => {
    setPage(newPage)
    // Use setTimeout to ensure DOM has updated before scrolling
    setTimeout(() => {
      scrollToTop()
    }, 100)
  }

  useEffect(() => { setPage(1) }, [query, selectedYears])
  useEffect(() => { setPage(1) }, [pageSize])

  useEffect(() => {
    if (!query) return
    let alive = true
    const ac = new AbortController()
    ;(async () => {
      setLoading(true)
      setErr('')
      try {
        const url = `/query/${encodeURIComponent(query)}/studies`
        const res = await fetch(url, { signal: ac.signal })
        const data = await res.json().catch(() => ({}))
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`)
        if (!alive) return
        const list = Array.isArray(data?.results) ? data.results : []
        setRows(list)
      } catch (e) {
        if (!alive) return
        setErr(`Unable to fetch studies: ${e?.message || e}`)
        setRows([])
      } finally {
        if (alive) setLoading(false)
      }
    })()
    return () => { alive = false; ac.abort() }
  }, [query])

  const changeSort = (key) => {
    // 只有 year 可以排序
    if (key !== 'year') return
    if (key === sortKey) setSortDir(d => (d === 'asc' ? 'desc' : 'asc'))
    else { setSortKey(key); setSortDir('asc') }
  }

  const sorted = useMemo(() => {
    let arr = [...rows]
    
    // 根據選中的年份過濾
    if (selectedYears.length > 0) {
      arr = arr.filter(r => {
        const year = String(r?.year || '')
        return selectedYears.includes(year)
      })
    }
    
    // 排序
    const dir = sortDir === 'asc' ? 1 : -1
    arr.sort((a, b) => {
      const A = a?.[sortKey]
      const B = b?.[sortKey]
      if (sortKey === 'year') return (Number(A || 0) - Number(B || 0)) * dir
      if (sortKey === 'pubmed') {
        const idA = a?.study_id || a?.id || a?.pubmed_id || ''
        const idB = b?.study_id || b?.id || b?.pubmed_id || ''
        return String(idA).localeCompare(String(idB), 'en') * dir
      }
      return String(A || '').localeCompare(String(B || ''), 'en') * dir
    })
    return arr
  }, [rows, sortKey, sortDir, selectedYears])

  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize))
  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize)

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      handlePageChange(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur() // 讓輸入框失去焦點
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // 當頁碼改變時，同步更新輸入框（但只在不是用戶正在輸入時）
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="studies">
      <YearFilter 
        selectedYears={selectedYears} 
        onYearsChange={setSelectedYears}
        query={query}
        searchResults={rows}
      />

      {query && !loading && !err && (
        <div className="studies__header" ref={tableTopRef}>
          <div className="studies__header-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <PageSizeSelector pageSize={pageSize} onChange={setPageSize} />
          <div className="studies__header-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(Math.max(1, page - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(Math.min(totalPages, page + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}

      {query && loading && (
        <div className="studies__skeleton">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="studies__skeleton-row" />
          ))}
        </div>
      )}

      {query && err && (
        <div className="studies__error">
          {err}
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__table-wrapper">
          <table className="studies__table">
            <thead className="studies__thead">
              <tr>
                <th 
                  className="studies__th"
                  onClick={() => changeSort('year')}
                >
                  <span className="studies__th-content">
                    Year
                    <span className="studies__sort-indicator">
                      {sortKey === 'year' ? (sortDir === 'asc' ? '▲' : '▼') : ''}
                    </span>
                  </span>
                </th>
              </tr>
            </thead>
            <tbody>
              {pageRows.length === 0 ? (
                <tr>
                  <td colSpan={2} className="studies__empty-cell">
                    No data
                  </td>
                </tr>
              ) : (
                pageRows.map((r, i) => {
                  const globalIndex = (page - 1) * pageSize + i
                  const pubmedUrl = getPubMedUrl(r.study_id || r.id || r.pubmed_id)
                  return (
                    <>
                      <tr 
                        key={`row-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td className="studies__td studies__td--year">
                          {r.year ?? ''}
                        </td>
                        <td className="studies__td studies__td--title">
                          <div className="studies__title-cell" title={r.title}>
                            {r.title || ''}
                          </div>
                        </td>
                      </tr>
                      <tr 
                        key={`detail-${globalIndex}`}
                        className={classNames(
                          'studies__tr',
                          'studies__tr--detail',
                          i % 2 ? 'studies__tr--even' : 'studies__tr--odd'
                        )}
                      >
                        <td colSpan={2} className="studies__td studies__td--detail">
                          <div className="studies__detail-content">
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Journal:</span>
                              <span className="studies__detail-value">{r.journal || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">Authors:</span>
                              <span className="studies__detail-value">{r.authors || '—'}</span>
                            </div>
                            <div className="studies__detail-row">
                              <span className="studies__detail-label">PubMed:</span>
                              {pubmedUrl ? (
                                <a
                                  href={pubmedUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="studies__pubmed-link"
                                  title={`View on PubMed: ${r.study_id || r.id || r.pubmed_id}`}
                                >
                                  <span>{r.study_id || r.id || r.pubmed_id}</span>
                                  <svg width="14" height="14" viewBox="0 0 20 20" fill="none">
                                    <path d="M11 3h6v6M17 3l-8 8M17 11v6H3V3h6" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                                  </svg>
                                </a>
                              ) : (
                                <span className="studies__no-pubmed">—</span>
                              )}
                            </div>
                          </div>
                        </td>
                      </tr>
                    </>
                  )
                })
              )}
            </tbody>
          </table>
        </div>
      )}

      {query && !loading && !err && (
        <div className="studies__pagination">
          <div className="studies__pagination-info">
            <b>{sorted.length}</b> results, page{' '}
            <input
              type="number"
              min="1"
              max={totalPages}
              value={pageInput}
              onChange={(e) => setPageInput(e.target.value)}
              onKeyDown={handlePageInputKeyDown}
              onBlur={handlePageInputBlur}
              className="studies__page-input"
            />
            {' '}/ <b>{totalPages}</b>
          </div>
          <div className="studies__pagination-controls">
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(1)}
              className="studies__pagination-button"
            >
              &lt;&lt;
            </button>
            <button 
              disabled={page <= 1} 
              onClick={() => handlePageChange(Math.max(1, page - 1))}
              className="studies__pagination-button"
            >
              &lt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(Math.min(totalPages, page + 1))}
              className="studies__pagination-button"
            >
              &gt;
            </button>
            <button 
              disabled={page >= totalPages} 
              onClick={() => handlePageChange(totalPages)}
              className="studies__pagination-button"
            >
              &gt;&gt;
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

```

```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
  border-color: var(--fg-dark);
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: transparent;
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: none;
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: none;
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 96px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已完成以下修改：

1. **刪除 Title 欄位**：移除了 header 中的 `<th>` 元素，只保留 "Year"
2. **移除灰色背景**：將 `.studies__thead` 的 `background` 從 `var(--bg-light)` 改為 `transparent`

現在表格 header 只顯示 "Year"，且沒有灰色背景。修改完成，無 lint 錯誤。

---

**User**

@Studies.css @Studies.jsx標題studies文字左邊的直線刪除

---

**Cursor**


檢查目前的程式碼結構，找出標題 "studies" 的位置：


檢查 CSS 中是否有 `border-left` 或偽元素：


檢查 `CardTitle` 組件的樣式，確認是否有左邊直線：


檢查 Card 組件的樣式：


移除 `CardTitle` 的左側直線（`::before` 偽元素）：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

已移除標題左邊的直線。我刪除了 `.card__title::before` 偽元素，該元素會在所有 CardTitle（包括 "Studies" 標題）的左側顯示一條直線。

修改完成，無 lint 錯誤。現在 "Studies" 標題左側不會再有直線。

---

**User**

NIfTI Viewer左邊的直線也刪除

---

**Cursor**


檢查 NIfTI Viewer 相關代碼，確認是否也需要移除左邊直線：


檢查 NiiViewer 組件，確認標題樣式：


移除 NiiViewer 標題左邊的直線：


```css
.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}
```

重新讀取文件以確認內容：


刪除 `::before` 偽元素：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已移除 NIfTI Viewer 標題左邊的直線。我刪除了 `.nii-viewer__title::before` 偽元素，該元素會在 "NIfTI Viewer" 標題左側顯示一條直線。

修改完成，無 lint 錯誤。現在 "NIfTI Viewer" 標題左側不會再有直線。

---

**User**

@Studies.css @Studies.jsx 讓使用者可以自行調整頁數的那個框框不要有匡線

---

**Cursor**


移除頁數輸入框的邊框：


```css
.studies {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.studies__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.studies__header-info {
  color: var(--fg);
  font-size: 13px;
  white-space: nowrap;
  flex-shrink: 0;
}

.studies__header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.studies__page-input {
  width: 50px;
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.studies__page-input:focus {
  outline: none;
}

.studies__skeleton {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 12px;
}

.studies__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

.studies__error {
  margin: 0 12px 12px;
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.studies__table-wrapper {
  overflow-x: hidden;
  overflow-y: auto;
}

.studies__table {
  width: 100%;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}

.studies__thead {
  position: sticky;
  top: 0;
  background: transparent;
  z-index: 10;
}

.studies__th {
  padding: 8px 12px;
  text-align: left;
  font-weight: 600;
  user-select: none;
  border-bottom: none;
  transition: background 0.15s ease;
}

.studies__th:not(.studies__th--no-sort) {
  cursor: pointer;
}

.studies__th:not(.studies__th--no-sort):hover {
  background: rgba(0, 0, 0, 0.02);
}

.studies__th--no-sort {
  cursor: default;
}

.studies__th-content {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.studies__sort-indicator {
  font-size: 10px;
  color: var(--muted);
}

.studies__tr {
  transition: background 0.15s ease;
}

.studies__tr--detail {
  background: transparent;
}

.studies__tr--odd {
  background: transparent;
}

.studies__tr--even {
  background: transparent;
}

.studies__td {
  padding: 8px 12px;
  vertical-align: top;
  border-bottom: none;
}

.studies__td--year {
  white-space: nowrap;
  width: 60px;
  text-align: center;
}

.studies__th:first-child {
  text-align: center;
  width: 60px;
}

.studies__td--title {
  width: auto;
  word-wrap: break-word;
  word-break: break-word;
}

.studies__td--detail {
  padding-top: 12px;
  padding-right: 12px;
  padding-bottom: 12px;
  padding-left: 96px;
  background: transparent;
}

.studies__detail-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 0;
  margin-left: 0;
}

.studies__detail-row {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}

.studies__detail-label {
  font-weight: 600;
  color: var(--fg-dark);
  min-width: 80px;
  flex-shrink: 0;
}

.studies__detail-value {
  color: var(--fg);
  flex: 1;
}

.studies__title-cell {
  overflow: visible;
  white-space: normal;
  word-wrap: break-word;
  word-break: break-word;
  line-height: 1.5;
  font-size: 17px;
  font-weight: 700;
  color: #004B97;
}

.studies__empty-cell {
  padding: 24px;
  text-align: center;
  color: var(--muted);
}

.studies__pubmed-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  color: #006400;
  text-decoration: none;
  font-weight: 500;
  transition: all 0.15s ease;
}

.studies__pubmed-link:hover {
  color: #228B22;
  text-decoration: underline;
}

.studies__pubmed-link svg {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.studies__pubmed-link:hover svg {
  opacity: 1;
}

.studies__no-pubmed {
  color: var(--muted);
}

.studies__pagination {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-top: 1px solid var(--border);
  padding: 12px;
  font-size: 13px;
  gap: 16px;
  flex-wrap: wrap;
}

.studies__pagination-info {
  color: var(--fg);
}

.studies__pagination-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.studies__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.studies__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.studies__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}


```

已移除頁數輸入框的邊框。修改如下：

1. **移除邊框**：將 `.studies__page-input` 的 `border` 從 `1px solid var(--border)` 改為 `none`
2. **簡化 focus 樣式**：移除了 focus 狀態下的 `border-color`，只保留 `outline: none`

現在頁數輸入框不會顯示邊框。修改完成，無 lint 錯誤。

---

**User**

@Terms.css @Terms.jsx clear按鈕刪除，改成在搜尋欄的最右邊有X按鈕可以點擊 

---

**Cursor**


檢查目前的結構，準備移除 Clear 按鈕，並在搜尋欄右側添加 X 清除按鈕。


移除 Clear 按鈕，並在搜尋欄右側新增 X 清除按鈕：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
            >
              ×
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.terms__clear-icon:hover {
  color: var(--fg-dark);
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }

  .terms__clear-button {
    width: 100%;
  }
}


```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.terms__clear-icon:hover {
  color: var(--fg-dark);
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已完成以下修改：

1. **移除 Clear 按鈕**：刪除了獨立的 Clear 按鈕
2. **新增 X 按鈕**：在搜尋欄右側新增 X 清除按鈕
3. **條件顯示**：只在有搜尋內容時顯示 X 按鈕
4. **樣式調整**：
   - 新增 `terms__input-wrapper` 作為相對定位容器
   - 調整輸入框右側 padding 為 40px，為 X 按鈕留出空間
   - X 按鈕使用絕對定位，置於輸入框右側
   - hover 時顏色變深

現在搜尋欄右側會顯示 X 按鈕（僅在有內容時），點擊可清除搜尋。修改完成，無 lint 錯誤。

---

**User**

我沒有看到Ｘ按鈕

---

**Cursor**


檢查目前的代碼，確認 X 按鈕是否有顯示問題：


調整 X 按鈕的樣式，改用更明顯的 X 符號，並確保正確顯示：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              ✕
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 20px;
  line-height: 1;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10;
  font-weight: 300;
}

.terms__clear-icon:hover {
  color: var(--fg-dark);
  font-weight: 400;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

改用 SVG 圖標，確保 X 按鈕能正確顯示：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 4L4 12M4 4l8 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  background: none;
  border: none;
  color: var(--muted);
  cursor: pointer;
  padding: 4px;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10;
}

.terms__clear-icon:hover {
  color: var(--fg-dark);
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已改用 SVG 圖標顯示 X。若仍不明顯，可能是顏色太淡。調整顏色以提升可見度：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  background: none;
  border: none;
  color: #999;
  cursor: pointer;
  padding: 4px;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10;
}

.terms__clear-icon:hover {
  color: var(--fg-dark);
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

---

**User**

改成這個叉叉符號@icons8-delete.svg 

---

**Cursor**


將 X 按鈕圖標改為使用提供的 SVG 檔案：


更新 X 按鈕為使用提供的 SVG 圖標：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="16" height="16">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

已將 X 按鈕圖標改為使用 `icons8-delete.svg`。修改內容：

1. **替換 SVG**：使用提供的圓圈 X 圖標
2. **調整大小**：將寬高設為 16px，與按鈕大小一致
3. **顏色繼承**：使用 `fill="currentColor"`，讓圖標繼承按鈕的顏色

現在 X 按鈕會顯示為圓圈內的 X 圖標，顏色會隨 hover 狀態變化。修改完成，無 lint 錯誤。

---

**User**

我還是沒有看到這個按鈕 是為什麼

---

**Cursor**


檢查代碼，找出 X 按鈕未顯示的原因：


調整 CSS，確保按鈕在輸入時可見，並加強顏色對比：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #000;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已調整 CSS：
1. 使用 `top: 50%` 和 `transform: translateY(-50%)` 垂直置中
2. 顏色改為 `#666`，hover 為 `#000`
3. 明確設定 `opacity: 1`

**請確認**：X 按鈕只在輸入框有內容時顯示。請在搜尋框輸入文字後檢查是否出現。

如果已輸入但仍看不到，請告訴我：
1. 是否已在輸入框中輸入文字？
2. 瀏覽器開發者工具中是否能看到按鈕元素？

也可以先讓按鈕始終顯示（無條件）以便測試：


調整 SVG 尺寸，確保圖標更明顯：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="18" height="18">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

已調整 CSS 和 SVG 尺寸。請確認：

1. **是否已在搜尋框輸入文字**：按鈕只在有輸入時顯示；若輸入框為空，按鈕不會顯示。
2. **按鈕位置**：應在輸入框右側、垂直居中。

已在 CSS 中加入垂直居中與明確的顏色設定。請在搜尋框輸入文字後測試。若仍看不到，請告知您的瀏覽器與版本，我再進一步檢查。

---

**User**

我看到按鈕了 我希望滑鼠過去時維持原本顏色就好 然後要有鼠標變成手指

---

**Cursor**


調整 CSS：hover 時維持原本顏色，並確保游標為手指圖示：


移除 hover 時的顏色變化，保持原本顏色：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已更新 CSS：

1. **維持原本顏色**：hover 時顏色保持 `#666`，不會變色
2. **手指游標**：已設定 `cursor: pointer`，滑鼠移到按鈕上時會顯示手指游標

現在 X 按鈕在 hover 時會維持原本顏色，且游標會變成手指。修改完成，無 lint 錯誤。

---

**User**

可是我看到還是會變成黑色的

---

**Cursor**


檢查 CSS，移除 hover 時的顏色變化：


移除 `transition` 對顏色的影響，或完全移除 hover 狀態，確保顏色不變：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

檢查 SVG 的 fill 屬性。為確保顏色不變，設定 `!important`：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--bg-light);
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: var(--fg-dark);
  color: white;
  border-color: var(--fg-dark);
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已更新 CSS：

1. **移除 transition**：避免顏色過渡
2. **使用 `!important`**：確保 hover 時顏色固定為 `#666`
3. **設定 SVG path**：明確使用 `fill: currentColor` 繼承按鈕顏色

現在 hover 時顏色應保持 `#666` 不變。請測試確認。若仍有問題，可能是其他 CSS 規則影響，請告知。

---

**User**

@Terms.jsx @Terms.css 所有terms的匡線都刪除 然後所有terms底色改成高透明度的漸層淺黃色到白色

---

**Cursor**


檢查目前的 CSS，準備移除所有 terms 的邊框，並將背景改為高透明度的淺黃到白色漸層。


移除所有 terms 的邊框，並將背景改為高透明度的淺黃到白色漸層：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: linear-gradient(to right, rgba(255, 248, 200, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: linear-gradient(to right, rgba(255, 248, 200, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已更新 CSS：

1. **移除所有邊框**：將 `.terms__name` 的 `border` 從 `1px solid var(--border)` 改為 `none`
2. **新增漸層背景**：
   - 預設：`linear-gradient(to right, rgba(255, 248, 200, 0.4), rgba(255, 255, 255, 0.2))`（淺黃到白色，高透明度）
   - hover：稍微加深透明度，保持漸層效果

現在所有 terms 標籤都：
- 沒有邊框
- 使用高透明度的淺黃到白色漸層背景
- hover 時漸層會稍微加深

修改完成，無 lint 錯誤。

---

**User**

用這個色號#FFED97試試

---

**Cursor**


將漸層中的淺黃色改為 `#FFED97`：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: linear-gradient(to right, rgba(255, 237, 151, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: linear-gradient(to right, rgba(255, 237, 151, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將漸層中的淺黃色改為 `#FFED97`（RGB: 255, 237, 151）。

- 預設：`rgba(255, 237, 151, 0.4)` 到 `rgba(255, 255, 255, 0.2)`
- hover：`rgba(255, 237, 151, 0.5)` 到 `rgba(255, 255, 255, 0.3)`

現在 terms 標籤使用 `#FFED97` 到白色的高透明度漸層。修改完成，無 lint 錯誤。

---

**User**

換成#C4E1FF	

---

**Cursor**


將漸層顏色改為 `#C4E1FF`：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: linear-gradient(to right, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: linear-gradient(to right, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將漸層顏色改為 `#C4E1FF`（RGB: 196, 225, 255）。

- 預設：`rgba(196, 225, 255, 0.4)` 到 `rgba(255, 255, 255, 0.2)`
- hover：`rgba(196, 225, 255, 0.5)` 到 `rgba(255, 255, 255, 0.3)`

現在 terms 標籤使用 `#C4E1FF` 到白色的高透明度漸層。修改完成，無 lint 錯誤。

---

**User**

改回#FFED97好了

---

**Cursor**


將漸層顏色改回 `#FFED97`：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: linear-gradient(to right, rgba(255, 237, 151, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: linear-gradient(to right, rgba(255, 237, 151, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將漸層顏色改回 `#FFED97`（RGB: 255, 237, 151）。

- 預設：`rgba(255, 237, 151, 0.4)` 到 `rgba(255, 255, 255, 0.2)`
- hover：`rgba(255, 237, 151, 0.5)` 到 `rgba(255, 255, 255, 0.3)`

現在 terms 標籤使用 `#FFED97` 到白色的高透明度漸層。修改完成，無 lint 錯誤。

---

**User**

可以改成同心圓式的漸層嗎

---

**Cursor**


將漸層改為同心圓式（radial gradient）：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: radial-gradient(circle, rgba(255, 237, 151, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: radial-gradient(circle, rgba(255, 237, 151, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將漸層改為同心圓式（radial gradient）：

- 預設：`radial-gradient(circle, rgba(255, 237, 151, 0.4), rgba(255, 255, 255, 0.2))` — 從中心淺黃色向外擴散到白色
- hover：`radial-gradient(circle, rgba(255, 237, 151, 0.5), rgba(255, 255, 255, 0.3))` — 稍微加深

現在 terms 標籤使用同心圓式漸層，從中心的 `#FFED97` 向外擴散到白色。修改完成，無 lint 錯誤。

---

**User**

改用#C4E1FF好了

---

**Cursor**


將漸層顏色改為 `#C4E1FF`：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: radial-gradient(circle, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: radial-gradient(circle, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--muted);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將漸層顏色改為 `#C4E1FF`（RGB: 196, 225, 255）。

- 預設：`radial-gradient(circle, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2))` — 從中心藍色向外擴散到白色
- hover：`radial-gradient(circle, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3))` — 稍微加深

現在 terms 標籤使用同心圓式漸層，從中心的 `#C4E1FF` 向外擴散到白色。修改完成，無 lint 錯誤。

---

**User**

@Terms.css @Terms.jsx 顯示 Total 3168 terms, page 1/106 的這個東西改成3,168 results ，page的部分改成可以調整頁數，跟@Studies.css @Studies.jsx 的樣式相同



---

**Cursor**


檢查 Studies 組件的頁數輸入框實現，以便在 Terms 組件中套用相同樣式：


修改 Terms 組件，更新顯示格式並添加頁數輸入框：


修改 Terms 組件，更新顯示格式並添加頁數輸入框：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const [pageInput, setPageInput] = useState('1')
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="18" height="18">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const [pageInput, setPageInput] = useState('1')
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  // Format number with commas
  const formatNumber = (num) => {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  }

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur()
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // Sync pageInput with page
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="18" height="18">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                Total <b>{totalItems}</b> terms, page <b>{page}</b>/<b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const [pageInput, setPageInput] = useState('1')
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  // Format number with commas
  const formatNumber = (num) => {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  }

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur()
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // Sync pageInput with page
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="18" height="18">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                <b>{formatNumber(totalItems)}</b> results, page{' '}
                <input
                  type="number"
                  min="1"
                  max={totalPages}
                  value={pageInput}
                  onChange={(e) => setPageInput(e.target.value)}
                  onKeyDown={handlePageInputKeyDown}
                  onBlur={handlePageInputBlur}
                  className="terms__page-input"
                />
                {' '}/ <b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  ⏮
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  Previous
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  Next
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  ⏭
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: radial-gradient(circle, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: radial-gradient(circle, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--fg);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__page-input {
  width: 50px;
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.terms__page-input:focus {
  outline: none;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 60px;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  background: var(--border);
  color: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已更新 Terms 組件：

1. **顯示格式**：將 "Total 3168 terms, page 1/106" 改為 "3,168 results, page [輸入框] / 106"
   - 使用 `formatNumber` 函數添加千分位逗號
   - 將 "terms" 改為 "results"

2. **頁數輸入框**：
   - 添加 `pageInput` state
   - 添加 `handlePageJump`、`handlePageInputKeyDown`、`handlePageInputBlur` 函數
   - 添加頁數輸入框，樣式與 Studies 組件相同

3. **CSS 樣式**：
   - 添加 `.terms__page-input` 樣式，與 `.studies__page-input` 相同
   - 更新 `.terms__pagination-info` 的顏色，與 Studies 一致

現在 Terms 組件的分頁顯示和輸入框與 Studies 組件一致。修改完成，無 lint 錯誤。

---

**User**

@Terms.css @Terms.jsx 的previous, next這四個按鈕改成跟@Studies.css @Studies.jsx 的按鈕一樣樣式

---

**Cursor**


檢查 Studies 組件的分頁按鈕樣式，然後套用到 Terms 組件：


更新 Terms 組件的按鈕文字與樣式，使其與 Studies 組件一致：


```javascriptreact
import { useEffect, useMemo, useState } from 'react'
import './Terms.css'

export function Terms ({ onPickTerm }) {
  const [terms, setTerms] = useState([])
  const [search, setSearch] = useState('')
  const [loading, setLoading] = useState(false)
  const [err, setErr] = useState('')
  const [page, setPage] = useState(1)
  const [pageInput, setPageInput] = useState('1')
  const rowsPerPage = 3 // 每頁顯示 3 行
  const estimatedItemsPerRow = 10 // 估計每行可以顯示的數量（用於計算分頁）- 減半後約每頁 30 個

  useEffect(() => {
    let alive = true
    const ac = new AbortController()
    const load = async () => {
      setLoading(true)
      setErr('')
      try {
        const res = await fetch('/terms', { signal: ac.signal })
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const data = await res.json()
        if (!alive) return
        setTerms(Array.isArray(data?.terms) ? data.terms : [])
      } catch (e) {
        if (!alive) return
        setErr(`Failed to fetch terms: ${e?.message || e}`)
      } finally {
        if (alive) setLoading(false)
      }
    }
    load()
    return () => { alive = false; ac.abort() }
  }, [])

  const filtered = useMemo(() => {
    const s = search.trim().toLowerCase()
    if (!s) return terms
    return terms.filter(t => t.toLowerCase().includes(s))
  }, [terms, search])

  const totalItems = filtered.length
  const estimatedItemsPerPage = rowsPerPage * estimatedItemsPerRow
  const totalPages = Math.max(1, Math.ceil(totalItems / estimatedItemsPerPage))
  const startIndex = (page - 1) * estimatedItemsPerPage
  const endIndex = startIndex + estimatedItemsPerPage
  const pageTerms = filtered.slice(startIndex, endIndex)

  useEffect(() => {
    if (page > totalPages && totalPages > 0) {
      setPage(totalPages)
    }
  }, [page, totalPages])

  // Format number with commas
  const formatNumber = (num) => {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  }

  const handlePageJump = () => {
    const pageNum = parseInt(pageInput, 10)
    if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= totalPages && pageNum !== page) {
      setPage(pageNum)
    }
  }

  const handlePageInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      handlePageJump()
      e.target.blur()
    }
  }

  const handlePageInputBlur = () => {
    handlePageJump()
  }

  // Sync pageInput with page
  useEffect(() => {
    setPageInput(String(page))
  }, [page])

  return (
    <div className="terms">
      <div className="terms__header">
        <h2 className="terms__title">Terms</h2>
      </div>
      
      <div className="terms__controls">
        <div className="terms__input-wrapper">
          <input
            value={search}
            onChange={(e) => {
              setSearch(e.target.value)
              setPage(1)
            }}
            placeholder="Search terms…"
            className="terms__input"
          />
          {search && (
            <button
              onClick={() => {
                setSearch('')
                setPage(1)
              }}
              className="terms__clear-icon"
              aria-label="Clear search"
              type="button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="18" height="18">
                <path d="M 25 2 C 12.309534 2 2 12.309534 2 25 C 2 37.690466 12.309534 48 25 48 C 37.690466 48 48 37.690466 48 25 C 48 12.309534 37.690466 2 25 2 z M 25 4 C 36.609534 4 46 13.390466 46 25 C 46 36.609534 36.609534 46 25 46 C 13.390466 46 4 36.609534 4 25 C 4 13.390466 13.390466 4 25 4 z M 32.990234 15.986328 A 1.0001 1.0001 0 0 0 32.292969 16.292969 L 25 23.585938 L 17.707031 16.292969 A 1.0001 1.0001 0 0 0 16.990234 15.990234 A 1.0001 1.0001 0 0 0 16.292969 17.707031 L 23.585938 25 L 16.292969 32.292969 A 1.0001 1.0001 0 1 0 17.707031 33.707031 L 25 26.414062 L 32.292969 33.707031 A 1.0001 1.0001 0 1 0 33.707031 32.292969 L 26.414062 25 L 33.707031 17.707031 A 1.0001 1.0001 0 0 0 32.990234 15.986328 z" fill="currentColor"/>
              </svg>
            </button>
          )}
        </div>
      </div>

      {loading && (
        <div className="terms__skeleton">
          {Array.from({ length: rowsPerPage }).map((_, i) => (
            <div key={i} className="terms__skeleton-row" />
          ))}
        </div>
      )}

      {err && (
        <div className="terms__error">
          {err}
        </div>
      )}

      {!loading && !err && (
        <>
          <div className="terms__list">
            {pageTerms.length === 0 ? (
              <div className="terms__empty">No terms found</div>
            ) : (
              <div className="terms__container">
                {pageTerms.map((t, idx) => (
                  <a
                    key={`${t}-${startIndex + idx}`}
                    href="#"
                    className="terms__name"
                    title={t}
                    aria-label={`Add term ${t}`}
                    onClick={(e) => { e.preventDefault(); onPickTerm?.(t); }}
                  >
                    {t}
                  </a>
                ))}
              </div>
            )}
          </div>

          {totalPages > 1 && (
            <div className="terms__pagination">
              <div className="terms__pagination-info">
                <b>{formatNumber(totalItems)}</b> results, page{' '}
                <input
                  type="number"
                  min="1"
                  max={totalPages}
                  value={pageInput}
                  onChange={(e) => setPageInput(e.target.value)}
                  onKeyDown={handlePageInputKeyDown}
                  onBlur={handlePageInputBlur}
                  className="terms__page-input"
                />
                {' '}/ <b>{totalPages}</b>
              </div>
              <div className="terms__pagination-controls">
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(1)}
                  className="terms__pagination-button"
                >
                  &lt;&lt;
                </button>
                <button 
                  disabled={page <= 1} 
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  className="terms__pagination-button"
                >
                  &lt;
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                  className="terms__pagination-button"
                >
                  &gt;
                </button>
                <button 
                  disabled={page >= totalPages} 
                  onClick={() => setPage(totalPages)}
                  className="terms__pagination-button"
                >
                  &gt;&gt;
                </button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}

```

```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: radial-gradient(circle, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: radial-gradient(circle, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--fg);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__page-input {
  width: 50px;
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.terms__page-input:focus {
  outline: none;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已將 Terms 組件的分頁按鈕樣式更新為與 Studies 組件一致：

1. **按鈕文字**：
   - 從 `⏮`, `Previous`, `Next`, `⏭` 改為 `<<`, `<`, `>`, `>>`

2. **CSS 樣式**：
   - `border-radius`: 從 `6px` 改為 `8px`
   - 移除 `font-weight: 600`
   - 移除 `min-width: 60px`
   - 新增 `outline: none`
   - `disabled` 狀態：改為 `opacity: 0.4`（移除背景色和顏色的變更）

現在 Terms 組件的分頁按鈕與 Studies 組件一致。修改完成，無 lint 錯誤。

---

**User**

@Terms.css @Terms.jsx terms底下的橫線刪除 感覺不需要顯示

---

**Cursor**


檢查並移除 Terms 組件底下的橫線：


移除 Terms 組件底下的橫線：


```css
.terms {
  width: 100%;
}

.terms__header {
  margin-bottom: 16px;
}

.terms__title {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: var(--fg-dark);
}

.terms__controls {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  width: 100%;
  align-items: stretch;
}

.terms__input-wrapper {
  flex: 1;
  position: relative;
  display: flex;
  align-items: center;
}

.terms__input {
  flex: 1;
  padding: 12px 40px 12px 16px;
  border: 2px solid var(--border);
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.2s ease;
  width: 100%;
  min-width: 0;
}

.terms__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.terms__clear-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #666 !important;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  opacity: 1;
}

.terms__clear-icon:hover {
  color: #666 !important;
}

.terms__clear-icon svg {
  width: 100%;
  height: 100%;
  display: block;
  color: inherit;
}

.terms__clear-icon svg path {
  fill: currentColor;
}

.terms__skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.terms__skeleton-row {
  height: 40px;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.terms__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
}

.terms__list {
  margin-bottom: 16px;
}

.terms__container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  width: 100%;
}

.terms__empty {
  padding: 24px;
  text-align: center;
  color: var(--muted);
  font-size: 14px;
}

.terms__row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.terms__name {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  color: var(--fg);
  text-decoration: none;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.15s ease;
  cursor: pointer;
  border: none;
  background: radial-gradient(circle, rgba(196, 225, 255, 0.4), rgba(255, 255, 255, 0.2));
  white-space: nowrap;
  flex-shrink: 0;
}

.terms__name:hover {
  background: radial-gradient(circle, rgba(196, 225, 255, 0.5), rgba(255, 255, 255, 0.3));
  color: var(--fg);
  border: none;
  transform: translateY(-1px);
}

.terms__pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  gap: 16px;
}

.terms__pagination-info {
  font-size: 13px;
  color: var(--fg);
}

.terms__pagination-info b {
  color: var(--fg-dark);
  font-weight: 600;
}

.terms__page-input {
  width: 50px;
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.terms__page-input:focus {
  outline: none;
}

.terms__pagination-controls {
  display: flex;
  gap: 8px;
}

.terms__pagination-button {
  padding: 6px 12px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  outline: none;
}

.terms__pagination-button:hover:not(:disabled) {
  background: var(--muted);
  transform: translateY(-1px);
}

.terms__pagination-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

@media (max-width: 768px) {
  .terms__controls {
    flex-direction: column;
  }
}


```

已移除 Terms 組件底下的橫線。已將 `.terms__pagination` 的 `border-top: 1px solid var(--border);` 移除。

現在分頁區域下方不會再顯示橫線。修改完成，無 lint 錯誤。

---

**User**

@QueryBuilder.css @QueryBuilder.jsx 搜尋欄底下的橫線刪除 Year Filter底下的橫線也刪除

---

**Cursor**


檢查相關組件，找出並移除橫線：


檢查 YearFilter 組件：


檢查 Card 組件中的 Divider：


移除 QueryBuilder 下方的橫線（CardDivider）和 YearFilter 下方的橫線：


移除 YearFilter 下方的橫線，並處理 QueryBuilder 下方的橫線：


```css
.year-filter {
  width: 100%;
  padding: 16px;
  background: white;
  border-radius: var(--radius);
  margin-bottom: 16px;
}

.year-filter__header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 12px;
}

.year-filter__title {
  margin: 0;
  font-size: 16px;
  font-weight: 700;
  color: var(--fg-dark);
}

.year-filter__controls {
  display: flex;
  gap: 8px;
}

.year-filter__control-button {
  padding: 4px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.year-filter__control-button:hover:not(:disabled) {
  background: var(--fg-dark);
  color: white;
}

.year-filter__control-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.year-filter__control-button--short {
  padding: 4px 8px;
  min-width: 36px;
}

.year-filter__skeleton {
  display: flex;
  gap: 4px;
  align-items: flex-end;
  height: 120px;
}

.year-filter__skeleton-bar {
  flex: 1;
  background: var(--bg-light);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
  min-height: 20px;
}

.year-filter__error {
  padding: 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 8px;
  color: #c33;
  font-size: 13px;
  text-align: center;
}

.year-filter__chart {
  display: flex;
  gap: 4px;
  align-items: flex-end;
  height: 120px;
  padding: 24px 0 20px 0;
  margin-bottom: 12px;
  user-select: none;
  -webkit-user-select: none;
}

.year-filter__bar-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
}

.year-filter__bar-wrapper {
  width: 100%;
  display: flex;
  align-items: flex-end;
  flex: 1;
  min-height: 0;
  margin-bottom: 8px;
}

.year-filter__bar {
  width: 100%;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;
  border-radius: 4px 4px 0 0;
  flex-shrink: 0; /* 防止被壓縮 */
  background-color: rgba(255, 255, 255, 0.5);
  background-image: repeating-linear-gradient(
    45deg,
    var(--bar-color),
    var(--bar-color) 1px,
    transparent 1px,
    transparent 3px
  );
  background-size: 4px 4px;
  opacity: 0.5;
}

.year-filter__bar:hover {
  opacity: 0.7;
  transform: translateY(-2px);
}

.year-filter__bar--selected {
  opacity: 1;
}

.year-filter__bar-label {
  font-size: 10px;
  font-weight: 600;
  color: var(--fg-dark);
  white-space: nowrap;
  margin-top: 0;
  margin-bottom: 0;
  transform: rotate(-45deg);
  transform-origin: center;
  text-align: center;
  width: 100%;
  flex-shrink: 0;
  height: 15px;
}

.year-filter__bar-check {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 16px;
  height: 16px;
  background: var(--fg-dark);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: bold;
}

.year-filter__info {
  font-size: 12px;
  color: var(--muted);
  text-align: center;
  padding-top: 8px;
  border-top: none;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 768px) {
  .year-filter__header {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }

  .year-filter__controls {
    justify-content: flex-end;
  }
}


```

移除 App.jsx 中的 CardDivider，並移除 YearFilter 下方的橫線：


```javascriptreact
import { useCallback, useRef, useState } from 'react'
import { QueryBuilder } from './components/QueryBuilder'
import { Studies } from './components/Studies'
import { NiiViewer } from './components/NiiViewer'
import { LandingPage } from './components/LandingPage'
import { AppHeader } from './components/AppHeader'
import { Terms } from './components/Terms'
import { Card, CardTitle, CardDivider } from './components/Card'
import { Resizer } from './components/Resizer'
import { useUrlQueryState } from './hooks/useUrlQueryState'
import './App.css'

export default function App () {
  const [showLanding, setShowLanding] = useState(true)
  const [query, setQuery] = useUrlQueryState('q')

  const handleStart = useCallback(() => {
    console.log('handleStart called, setting showLanding to false')
    setShowLanding(false)
    console.log('showLanding set to false, should render main app now')
  }, [])

  const handlePickTerm = useCallback((t) => {
    setQuery((q) => (q ? `${q} ${t}` : t))
  }, [setQuery])

  // --- resizable panes state ---
  const gridRef = useRef(null)
  const [sizes, setSizes] = useState([50, 50]) // [middle, right] - removed left pane
  const MIN_PX = 240

  const startDrag = (which, e) => {
    e.preventDefault()
    const startX = e.clientX
    const rect = gridRef.current.getBoundingClientRect()
    const total = rect.width
    const curPx = sizes.map(p => (p / 100) * total)

    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX
      if (which === 0) {
        let newMid = curPx[0] + dx
        let newRight = curPx[1] - dx
        if (newMid < MIN_PX) { newRight -= (MIN_PX - newMid); newMid = MIN_PX }
        if (newRight < MIN_PX) { newMid -= (MIN_PX - newRight); newRight = MIN_PX }
        const s1 = (newMid / total) * 100
        const s2 = (newRight / total) * 100
        setSizes([s1, Math.max(s2, 0)])
      }
    }
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove)
      window.removeEventListener('mouseup', onMouseUp)
    }
    window.addEventListener('mousemove', onMouseMove)
    window.addEventListener('mouseup', onMouseUp)
  }

  if (showLanding) {
    return <LandingPage onStart={handleStart} />
  }

  console.log('Rendering main app, query:', query, 'showLanding:', showLanding)

  return (
    <div className="app">
      <AppHeader onLogoClick={() => setShowLanding(true)} />
      
      <div className="app__terms-section">
        <Terms onPickTerm={handlePickTerm} />
      </div>

      <main className="app__grid" ref={gridRef}>
        <Card className="card--stack" style={{ flexBasis: `${sizes[0]}%` }}>
          <CardTitle>Query Builder</CardTitle>
          <QueryBuilder query={query} setQuery={setQuery} />
          <CardTitle>Studies</CardTitle>
          <Studies query={query} />
        </Card>

        <Resizer 
          ariaLabel="Resize middle/right" 
          onMouseDown={(e) => startDrag(0, e)} 
        />

        <Card style={{ flexBasis: `${sizes[1]}%` }}>
          <NiiViewer query={query} />
        </Card>
      </main>
    </div>
  )
}

```

已完成以下修改：

1. **移除 QueryBuilder 底下的橫線**：移除了 `App.jsx` 中 QueryBuilder 和 Studies 之間的 `<CardDivider />`。

2. **移除 Year Filter 底下的橫線**：將 `.year-filter__info` 的 `border-top` 從 `1px solid var(--border)` 改為 `none`。

現在 QueryBuilder 和 Year Filter 下方都不會再顯示橫線。修改完成，無 lint 錯誤。

---

**User**

把@QueryBuilder.css @QueryBuilder.jsx divide用的橫線都刪除

---

**Cursor**


檢查 QueryBuilder 組件中是否有 divider 相關的橫線：


檢查 QueryBuilder 組件中是否有任何 divider 或橫線：


確認 App.jsx 中 CardDivider 是否已移除，並檢查是否有其他需要移除的橫線：


已確認 App.jsx 中的 CardDivider 已移除。QueryBuilder 組件本身沒有 divider 元素。檢查是否還有其他地方需要處理：


清理 App.jsx 中未使用的 CardDivider import：


```javascriptreact
import { useCallback, useRef, useState } from 'react'
import { QueryBuilder } from './components/QueryBuilder'
import { Studies } from './components/Studies'
import { NiiViewer } from './components/NiiViewer'
import { LandingPage } from './components/LandingPage'
import { AppHeader } from './components/AppHeader'
import { Terms } from './components/Terms'
import { Card, CardTitle } from './components/Card'
import { Resizer } from './components/Resizer'
import { useUrlQueryState } from './hooks/useUrlQueryState'
import './App.css'

export default function App () {
  const [showLanding, setShowLanding] = useState(true)
  const [query, setQuery] = useUrlQueryState('q')

  const handleStart = useCallback(() => {
    console.log('handleStart called, setting showLanding to false')
    setShowLanding(false)
    console.log('showLanding set to false, should render main app now')
  }, [])

  const handlePickTerm = useCallback((t) => {
    setQuery((q) => (q ? `${q} ${t}` : t))
  }, [setQuery])

  // --- resizable panes state ---
  const gridRef = useRef(null)
  const [sizes, setSizes] = useState([50, 50]) // [middle, right] - removed left pane
  const MIN_PX = 240

  const startDrag = (which, e) => {
    e.preventDefault()
    const startX = e.clientX
    const rect = gridRef.current.getBoundingClientRect()
    const total = rect.width
    const curPx = sizes.map(p => (p / 100) * total)

    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX
      if (which === 0) {
        let newMid = curPx[0] + dx
        let newRight = curPx[1] - dx
        if (newMid < MIN_PX) { newRight -= (MIN_PX - newMid); newMid = MIN_PX }
        if (newRight < MIN_PX) { newMid -= (MIN_PX - newRight); newRight = MIN_PX }
        const s1 = (newMid / total) * 100
        const s2 = (newRight / total) * 100
        setSizes([s1, Math.max(s2, 0)])
      }
    }
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove)
      window.removeEventListener('mouseup', onMouseUp)
    }
    window.addEventListener('mousemove', onMouseMove)
    window.addEventListener('mouseup', onMouseUp)
  }

  if (showLanding) {
    return <LandingPage onStart={handleStart} />
  }

  console.log('Rendering main app, query:', query, 'showLanding:', showLanding)

  return (
    <div className="app">
      <AppHeader onLogoClick={() => setShowLanding(true)} />
      
      <div className="app__terms-section">
        <Terms onPickTerm={handlePickTerm} />
      </div>

      <main className="app__grid" ref={gridRef}>
        <Card className="card--stack" style={{ flexBasis: `${sizes[0]}%` }}>
          <CardTitle>Query Builder</CardTitle>
          <QueryBuilder query={query} setQuery={setQuery} />
          <CardTitle>Studies</CardTitle>
          <Studies query={query} />
        </Card>

        <Resizer 
          ariaLabel="Resize middle/right" 
          onMouseDown={(e) => startDrag(0, e)} 
        />

        <Card style={{ flexBasis: `${sizes[1]}%` }}>
          <NiiViewer query={query} />
        </Card>
      </main>
    </div>
  )
}

```

已完成以下修改：

1. **移除 CardDivider**：已從 `App.jsx` 移除 QueryBuilder 和 Studies 之間的 `<CardDivider />`（之前已移除）。
2. **清理未使用的 import**：已從 `App.jsx` 移除未使用的 `CardDivider` import。

QueryBuilder 組件本身沒有 divider 元素，且與 Studies 之間的橫線已移除。目前 QueryBuilder 中沒有 divider 橫線。

所有修改已完成，沒有 lint 錯誤。

---

**User**

那其他檔案有嗎 幫我檢查

---

**Cursor**


檢查整個專案中是否還有其他 divider 或橫線：


檢查其他可能使用 divider 的位置：


檢查其他可能使用 divider 的地方：


檢查主要組件文件是否有使用 CardDivider：


檢查結果如下：

1. CardDivider 未使用
   - `Card.jsx` 中定義了 `CardDivider`，但沒有被任何組件使用（已從 `App.jsx` 移除）
   - `Card.css` 中仍有 `.card__divider` 樣式，但未被使用

2. 其他邊框（非 divider）
   - `AppHeader.css`：`border-bottom` 是 header 底部邊框，屬於正常 UI
   - `Locations.css`：表格單元格的邊框（表格結構所需）
   - `Studies.css`：表格單元格的邊框（表格結構所需）
   - `YearFilter.css`：`border-top: none`（已移除）

結論：**沒有其他 divider 橫線**。`CardDivider` 組件和樣式目前未被使用。

是否要刪除未使用的 `CardDivider` 組件和樣式，還是保留以便將來使用？

---

**User**

@Studies.css @Studies.jsx Studies文字往下移動一點 因為剛剛把divider刪除了

---

**Cursor**


检查 "Studies" 文字的显示位置，调整样式使其下移：


为 "Studies" 标题添加额外的上边距，补偿删除 divider 后的间距：


为 "Studies" 标题添加额外的上边距，补偿删除 divider 后的间距：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card--stack .card__title:nth-of-type(2) {
  margin-top: 16px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

已為 "Studies" 標題添加 16px 上邊距，補償刪除 divider 後的間距。修改如下：

在 `Card.css` 中添加了 `.card--stack .card__title:nth-of-type(2)` 規則，讓 "Studies" 標題（第二個 CardTitle）有額外的上邊距，補償刪除 divider 後的視覺間距。

修改已完成，沒有 lint 錯誤。現在 "Studies" 文字會稍微往下移動，與 QueryBuilder 之間的間距更合適。

---

**User**

我看起來沒有差別 可以在移動一點嗎

---

**Cursor**


增加 "Studies" 標題的上邊距：


將上邊距從 16px 增加到 32px：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card--stack .card__title:nth-of-type(2) {
  margin-top: 32px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

已將 "Studies" 標題的上邊距從 16px 增加到 32px。間距應更明顯。若還需要調整，請告知。

---

**User**

看起來沒有變 幫我檢查問題出在哪

---

**Cursor**


檢查問題所在。先查看實際的 HTML 結構和樣式：


檢查 QueryBuilder 的結構，確認 `:nth-of-type` 是否正確匹配：


`:nth-of-type(2)` 可能無法正確匹配。改用更可靠的方法：使用相鄰兄弟選擇器或直接針對第二個 CardTitle：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card--stack .query-builder + .card__title {
  margin-top: 32px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

已將選擇器改為 `.card--stack .query-builder + .card__title`，用相鄰兄弟選擇器匹配緊跟在 QueryBuilder 後的 CardTitle（即 "Studies"）。

如果仍不明顯，可增加 `!important` 或調整邊距值。請測試是否生效。若仍無效果，我可以進一步調整。

---

**User**

@NiiViewer.css @NiiViewer.jsx 

- Threshold mode 的兩個選項改成button

- 當Threshold mode是value時，Threshold 預設0.05

- 匡線都刪除

- 調整座標的按鈕都改成在圖片底下，且可以透過偵測滑鼠在圖片上移動而調整綠色十字位置

---

**Cursor**


检查代码结构，开始实现这些修改：


创建任务列表并开始实现：


查看图片和按钮的完整结构：


逐步实现这些修改：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Threshold mode</span>
          <select 
            value={thrMode} 
            onChange={e=>setThrMode(e.target.value)} 
            className="nii-viewer__select"
          >
            <option value="value">Value</option>
            <option value="pctl">Percentile</option>
          </select>
        </label>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
                <canvas 
                  ref={canvasRef} 
                  className="nii-viewer__canvas"
                  onClick={(e)=>onCanvasClick(e, key)} 
                />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
                <canvas 
                  ref={canvasRef} 
                  className="nii-viewer__canvas"
                  onClick={(e)=>onCanvasClick(e, key)} 
                />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // mouse move to adjust crosshairs
  function onCanvasMouseMove (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
                <canvas 
                  ref={canvasRef} 
                  className="nii-viewer__canvas"
                  onClick={(e)=>onCanvasClick(e, key)} 
                />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // mouse move to adjust crosshairs
  function onCanvasMouseMove (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

更新 CSS：添加按钮样式、删除所有边框、调整布局：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: 1px solid var(--border);
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: 1px solid #fcc;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

修复 CSS 中残留的 border-color：


更新 TODO，并确保切换到 value 模式时阈值正确：


所有修改已完成。验证关键部分：


添加一个 useEffect，确保切换到 value 模式时，如果阈值是 0，则设为 0.05：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // mouse move to adjust crosshairs
  function onCanvasMouseMove (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

## 完成的修改：

1. **Threshold mode 改为按钮**：将 `select` 下拉菜单改为两个按钮（Value 和 Percentile），带激活状态样式。

2. **Threshold 默认值**：当 Threshold mode 为 value 时，默认值为 0.05。已设置初始值，并添加 `useEffect` 确保切换模式时正确。

3. **删除所有边框**：移除了所有 `border` 属性，包括：
   - `.nii-viewer__section`
   - `.nii-viewer__input` 和 `.nii-viewer__select`
   - `.nii-viewer__coordinate-input`
   - `.nii-viewer__canvas`
   - `.nii-viewer__skeleton-item`
   - `.nii-viewer__error`
   - `.nii-viewer__download-link`

4. **按钮位置和鼠标移动功能**：
   - 将调整坐标的按钮（−、+）移到图片下方
   - 添加 `onMouseMove` 事件处理函数，鼠标在图片上移动时会实时更新绿色十字位置
   - 保持点击功能不变

所有修改已完成，没有 lint 错误。现在界面更简洁，交互更流畅。

---

**User**

機制改成 當在圖片上點擊時綠色十字就會固定住不追隨滑鼠，下一次進入圖片時又會繼續追蹤滑鼠

---

**Cursor**


调整交互机制：点击后固定十字，鼠标再次进入时恢复追踪。查看当前代码结构：


实现新的交互机制：点击后固定十字，鼠标再次进入时恢复追踪。


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // mouse move to adjust crosshairs
  function onCanvasMouseMove (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

## 修改说明：

1. **添加锁定状态**：新增 `lockedAxes` 状态对象，跟踪每个轴（x, y, z）的十字是否被锁定。

2. **点击固定十字**：
   - `onCanvasClick`：点击时设置该轴为锁定状态（`lockedAxes[axis] = true`）
   - 点击后十字固定在点击位置，不再跟随鼠标

3. **鼠标移动追踪**：
   - `onCanvasMouseMove`：添加锁定检查
   - 若该轴已锁定，直接返回，不更新十字位置
   - 若未锁定，正常追踪鼠标

4. **鼠标进入恢复追踪**：
   - 新增 `onCanvasMouseEnter`：鼠标进入时解锁该轴（`lockedAxes[axis] = false`）
   - 鼠标再次进入图片时恢复追踪

现在的工作流程：
- 初始状态：鼠标移动时十字跟随
- 点击后：十字固定在点击位置，不再跟随
- 鼠标离开后再进入：恢复追踪

修改已完成，没有 lint 错误。可以测试新的交互机制。

---

**User**

在輸入座標XYZ那行最右邊加上 淺灰色的文字 Tip: Click to lock the cross.

---

**Cursor**


查找坐标输入行的位置，添加提示文字：


在坐标输入行最右侧添加提示文字，并更新 CSS：


添加提示文字并更新样式：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__label">
          <span>Threshold mode</span>
          <div className="nii-viewer__mode-buttons">
            <button
              className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('value')}
            >
              Value
            </button>
            <button
              className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
              onClick={() => setThrMode('pctl')}
            >
              Percentile
            </button>
          </div>
        </div>
        <br />
        {thrMode === 'value' ? (
          <>
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <br />
          </>
        ) : (
          <>
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
            <br />
          </>
        )}

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已在坐标输入行最右侧添加提示文字。

## 修改内容：

1. **在 JSX 中添加提示文字**：在 `nii-viewer__controls-row` div 的最后添加了 `<span className="nii-viewer__tip">Tip: Click to lock the cross.</span>`。

2. **添加 CSS 样式**：
   - 使用 `margin-left: auto` 将提示文字推到最右边
   - 设置字体大小为 `12px`
   - 使用 `color: var(--muted)` 设置为浅灰色
   - 添加 `font-style: italic` 设置为斜体

提示文字会显示在坐标输入行的最右边，使用浅灰色斜体样式。

修改已完成，没有 lint 错误。

---

**User**

Threshold mode 跟他對應到的數值 改成左右排列 不要換航

---

**Cursor**


查看当前代码结构，将 Threshold mode 和对应数值改为左右排列：


将 Threshold mode 和对应数值改为左右排列：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

添加 CSS 样式，使 Threshold mode 和数值输入框在同一行显示：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 Threshold mode 和对应数值改为左右排列，不再换行。

## 修改内容：

1. **JSX 结构调整**：
   - 将 Threshold mode 和数值输入框放在新的 `nii-viewer__threshold-row` div 中
   - 移除了所有 `<br />` 换行标签
   - 使用条件渲染在同一行显示对应的输入框

2. **CSS 样式**：
   - 添加 `.nii-viewer__threshold-row` 样式，使用 `display: flex` 实现左右排列
   - 设置 `gap: 24px` 控制间距
   - 将 threshold-row 内的 label 的 `margin-bottom` 设为 0，避免多余的间距

现在 Threshold mode 按钮和对应的数值输入框会在同一行显示，不会换行。

修改已完成，没有 lint 错误。

---

**User**

Download map文字改成#FF9797的底色

---

**Cursor**


查找 "Download map" 的样式，将背景色改为 #FF9797：


更新 "Download map" 的背景色为 #FF9797：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FF9797;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 "Download map" 链接的背景色设置为 #FF9797（浅红色/粉红色）。

修改内容：
- 在 `.nii-viewer__download-link` 中添加 `background: #FF9797;`
- hover 状态保持不变（悬停时仍为浅灰色背景）

修改已完成，没有 lint 错误。现在 "Download map" 链接会显示为 #FF9797 的背景色。

---

**User**

改成#FFD2D2

---

**Cursor**


将 "Download map" 的背景色改为 #FFD2D2：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: var(--bg-light);
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 "Download map" 的背景色更新为 #FFD2D2（更浅的粉红色）。

修改已完成，没有 lint 错误。现在链接会显示为 #FFD2D2 的背景色。

---

**User**

滑鼠指過去要變成更深的紅色

---

**Cursor**


修改 hover 状态，使悬停时背景变为更深的红色：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已更新：鼠标悬停时，"Download map" 链接的背景色会从 #FFD2D2（浅粉红色）变为 #FF9797（更深的红色）。

修改已完成，没有 lint 错误。现在鼠标悬停时会显示更深的红色背景。

---

**User**

輸入XYZ座標的地方改成整個往下一行 看起來好擠

---

**Cursor**


查看当前代码结构，将 XYZ 坐标输入移到下一行：


增加 XYZ 坐标输入行的上边距，使其与上方内容分离：


增加 XYZ 坐标输入行的上边距，使其与上方内容有更多间距：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 XYZ 坐标输入行的上边距从 8px 增加到 16px，使它与 Threshold mode 之间有更多间距，布局更宽松。

修改已完成，没有 lint 错误。现在 XYZ 坐标输入行与上方内容有更多间距，不会显得拥挤。

---

**User**

@NiiViewer.css @NiiViewer.jsx 圖片上方調整座標的功能改成不能讓使用者調整 圖片底下調整座標數字要同步上方座標位置且能夠讓使用者自己改數字

---

**Cursor**


查看当前代码结构，实现：
1. 图片上方的坐标输入框改为只读
2. 图片下方的数字与上方坐标同步，且可编辑


实现这些修改：
1. 将上方坐标输入框设为只读
2. 将图片下方的数字改为可编辑输入框，并与上方坐标同步


实现这些修改：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x') } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y') } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z') } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1] },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2] },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0] },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <span style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}>
                  {index}
                </span>
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { const xi = toIdxX(x); setIx(xi); setIy(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCy(String(idx2coord(srcY, ny, 'y'))) }
    else if (axis === 'y') { const xi = toIdxX(x); setIx(xi); setIz(srcY); setCx(String(idx2coord(xi, nx, 'x'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
    else { setIy(x); setIz(srcY); setCy(String(idx2coord(x, ny, 'y'))); setCz(String(idx2coord(srcY, nz, 'z'))) }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

添加 CSS 样式，美化图片下方的输入框：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: transparent;
  cursor: not-allowed;
}

.nii-viewer__coordinate-input[readonly] {
  background: var(--bg-light);
  cursor: default;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: transparent;
  cursor: not-allowed;
}

.nii-viewer__coordinate-input[readonly] {
  background: var(--bg-light);
  cursor: default;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

确保初始加载时也设置输入框的值：


所有修改已完成。检查一下是否需要调整：


## 完成的修改：

1. **图片上方的坐标输入框改为只读**：
   - 将 X, Y, Z (mm) 输入框设置为 `readOnly`
   - 移除 `onChange`、`onBlur`、`onKeyDown` 事件处理
   - 添加 CSS 样式，使只读输入框显示为浅灰色背景

2. **图片下方的数字改为可编辑输入框**：
   - 将显示数字的 `<span>` 改为 `<input type="number">`
   - 添加 `ixInput`、`iyInput`、`izInput` 状态来管理输入值
   - 添加 `commitSliceIndex` 函数来处理输入框的提交

3. **同步机制**：
   - 当 `ix`、`iy`、`iz` 变化时，`useEffect` 会自动同步：
     - 更新上方坐标输入框的值（mm）
     - 更新下方输入框的值（索引）
   - 当用户编辑下方输入框时，会更新索引，并自动同步上方坐标

4. **样式优化**：
   - 为只读坐标输入框添加样式（浅灰色背景）
   - 为可编辑的切片输入框添加样式（白色背景，聚焦时有阴影效果）

现在用户可以：
- 在图片下方的输入框中直接输入数字来调整坐标
- 上方的坐标会自动同步显示对应的 mm 值
- 上方的坐标输入框是只读的，不能直接编辑

修改已完成，没有 lint 错误。

---

**User**

調整座標大小的按鈕已經做好了 不需要多一個 幫我找找座標按鈕的程式碼放在哪

---

**Cursor**


查找坐标按钮的代码位置：


查看图片下方控制区域的完整代码：


调整坐标的按钮位于图片下方，具体位置如下：

**位置：** `src/components/NiiViewer.jsx` 第 **600-626 行**

```jsx
<div className="nii-viewer__slice-controls">
  <button
    disabled={index <= 0}
    onClick={() => setIndex(Math.max(0, index - 1))}
    className="nii-viewer__button"
  >
    −
  </button>
  <input
    type="number"
    min="0"
    max={max}
    value={inputValue}
    onChange={(e) => setInputValue(e.target.value)}
    onBlur={() => commitSliceIndex(key)}
    onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
    className="nii-viewer__slice-input"
    style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
  />
  <button
    disabled={index >= max}
    onClick={() => setIndex(Math.min(max, index + 1))}
    className="nii-viewer__button"
  >
    +
  </button>
</div>
```

这些按钮在每张图片下方，用于调整切片索引（− 和 +）。

需要删除这些按钮吗？如果删除，只保留输入框让用户直接输入数字。

```javascriptreact
<div className="nii-viewer__slice-controls">
  <button
    disabled={index <= 0}
    onClick={() => setIndex(Math.max(0, index - 1))}
    className="nii-viewer__button"
  >
    −
  </button>
  <input
    type="number"
    min="0"
    max={max}
    value={inputValue}
    onChange={(e) => setInputValue(e.target.value)}
    onBlur={() => commitSliceIndex(key)}
    onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
    className="nii-viewer__slice-input"
    style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
  />
  <button
    disabled={index >= max}
    onClick={() => setIndex(Math.min(max, index + 1))}
    className="nii-viewer__button"
  >
    +
  </button>
</div>
```

---

**User**

留下+-按鈕 不要上下按鈕 你檢查看看是不是有兩種版本的

---

**Cursor**


检查是否有两种按钮版本：


检查是否有其他按钮或样式：


检查结果：当前代码中只有一种按钮版本。

**图片下方的按钮位置**：`src/components/NiiViewer.jsx` 第 **600-626 行**

目前只有：
- `−`（减号）按钮：减少索引
- `+`（加号）按钮：增加索引

**没有找到上下箭头按钮**。当前代码中只有 `−` 和 `+` 按钮，没有上下按钮。

如果之前有上下按钮或其他版本的按钮，可能已被移除或不在当前代码中。目前只有 `−` 和 `+` 按钮。

需要我做什么调整吗？比如：
- 确认保留 `−` 和 `+` 按钮
- 或者查看是否有其他地方的按钮需要处理

---

**User**

上下的部分是可以刪除的嗎？

---

**Cursor**


检查代码中是否有上下箭头按钮（spinner）。可能是 `type="number"` 输入框的默认 spinner：


这些是浏览器为 `type="number"` 输入框默认显示的上下箭头（spinner）。可用 CSS 隐藏它们。添加样式隐藏这些 spinner：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: transparent;
  cursor: not-allowed;
}

.nii-viewer__coordinate-input[readonly] {
  background: var(--bg-light);
  cursor: default;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

修复 lint 警告，添加标准的 `appearance` 属性：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: transparent;
  cursor: not-allowed;
}

.nii-viewer__coordinate-input[readonly] {
  background: var(--bg-light);
  cursor: default;
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已隐藏数字输入框的默认上下箭头（spinner）。

现在图片下方的输入框只显示数字，不再显示浏览器默认的上下箭头按钮。只保留 `−` 和 `+` 按钮用于调整。

修改内容：
- 添加 CSS 规则隐藏 Chrome/Safari 的 spinner（`::-webkit-inner-spin-button` 和 `::-webkit-outer-spin-button`）
- 添加 CSS 规则隐藏 Firefox 的 spinner（`-moz-appearance: textfield`）
- 添加标准的 `appearance` 属性以确保兼容性

修改已完成，没有 lint 错误。现在输入框不会有上下箭头，只保留 `−` 和 `+` 按钮。

---

**User**

NIfTI Viewer 上下方的座標顯示要同步

---

**Cursor**


检查当前的同步逻辑，确保上下方坐标显示同步：


检查同步逻辑，确保上下方坐标显示同步：


检查并优化同步逻辑，确保上下方坐标始终同步：


修复 `onCanvasClick` 和 `onCanvasMouseMove` 中直接更新坐标的问题，改为通过更新索引触发同步：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
        setCx('0'); setCy('0'); setCz('0')
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

检查并修复初始加载时的同步问题：


修复初始加载时的同步问题，移除直接设置坐标值：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
          setCx('0'); setCy('0'); setCz('0')
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

已修复同步问题。现在上下方的坐标显示会同步。

## 修改内容：

1. **修复 `onCanvasClick` 和 `onCanvasMouseMove`**：
   - 移除直接更新坐标（`setCx`, `setCy`, `setCz`）
   - 只更新索引（`setIx`, `setIy`, `setIz`）
   - 由 `useEffect` 统一同步坐标和输入框

2. **修复初始加载**：
   - 移除直接设置坐标值（`setCx('0')` 等）
   - 只设置索引，让 `useEffect` 处理坐标转换

3. **同步机制**：
   - `useEffect` 监听 `ix`, `iy`, `iz`, `dims` 的变化
   - 自动更新：
     - 上方坐标显示（`cx`, `cy`, `cz` - mm 单位）
     - 下方输入框值（`ixInput`, `iyInput`, `izInput` - 索引数字）

现在无论通过以下哪种方式改变坐标，上下方都会同步：
- 点击图片
- 鼠标移动
- 点击 `−` 或 `+` 按钮
- 编辑下方输入框并提交

修改已完成，没有 lint 错误。上下方的坐标显示已同步。

---

**User**

他們還是沒有同步 幫我檢查是為什麼

---

**Cursor**


检查同步逻辑，找出未同步的原因：


检查 `idx2coord` 函数和同步逻辑：


检查 `useEffect` 依赖项和 `idx2coord` 函数是否正确：


`idx2coord` 内部使用了 `getVoxelMM()`，依赖 `bgRef` 和 `mapRef`，但这些 ref 的变化不会触发 `useEffect`。确保在数据加载完成后同步更新。使用 `useMemo` 或添加额外的监听来修复：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    // Use the actual dims from bgRef or mapRef if available
    const bgDims = bgRef.current?.dims
    const mapDims = mapRef.current?.dims
    const actualDims = bgDims || mapDims || dims
    
    // Only sync if we have valid dimensions
    if (actualDims && actualDims[0] && actualDims[1] && actualDims[2]) {
      setCx(String(idx2coord(ix, actualDims[0], 'x')))
      setCy(String(idx2coord(iy, actualDims[1], 'y')))
      setCz(String(idx2coord(iz, actualDims[2], 'z')))
    }
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, bgRef.current, mapRef.current])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

问题在于 `useEffect` 依赖项中的 `bgRef.current` 和 `mapRef.current` 不会触发重新渲染。改用状态跟踪，并确保加载完成后触发同步：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

检查按钮点击时的同步。添加调试日志，并确保 `commitSliceIndex` 也触发同步：


检查同步逻辑，定位问题：


实现实时同步：编辑下方输入框时，如果输入有效，立即更新索引和坐标：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key) } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

检查 `idx2coord` 函数是否依赖 `getVoxelMM()`，以及是否需要修复：


添加一个额外的 `useEffect`，确保在 ref 加载完成后也触发同步：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              readOnly
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              readOnly
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              readOnly
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

已完成以下修改以修复同步问题：

## 修改内容：

1. **添加实时更新机制**：
   - 新增 `handleSliceInputChange` 函数
   - 当用户编辑下方输入框时，如果输入是有效数字，立即更新索引（`ix`/`iy`/`iz`）
   - 触发 `useEffect` 自动同步上方坐标和下方输入框

2. **改进同步 useEffect**：
   - 添加 `loadingBG` 和 `loadingMap` 作为依赖项
   - 确保在 ref 加载完成后也触发同步
   - 添加检查，确保 ref 已加载后才计算坐标

现在同步机制：
- 点击按钮时：更新索引 → `useEffect` 同步上方坐标和下方输入框
- 编辑输入框时：如果输入有效，立即更新索引 → `useEffect` 同步上方坐标
- 点击图片时：更新索引 → `useEffect` 同步上方坐标和下方输入框
- 鼠标移动时：更新索引 → `useEffect` 同步上方坐标和下方输入框

修改已完成，没有 lint 错误。上下方的坐标显示应该已同步。如果仍有问题，请说明具体场景，我会继续检查。

---

**User**

@NiiViewer.css @NiiViewer.jsx 做成跟這個圖片一樣的樣式，然後把手動輸入座標的功能放回去搜尋XYZ那邊

---

**Cursor**


恢复上方坐标输入框的可编辑功能，并调整样式以匹配图片：


恢复上方坐标输入框的可编辑功能，并调整样式以匹配图片：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
        </div>
      </div>

      {/* --- Threshold mode & value --- */}
      <div className="nii-viewer__section">
        <div className="nii-viewer__threshold-row">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
        </div>

        {/* Neurosynth-style coordinate inputs (signed, centered at 0) */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

确保同步逻辑正确，并添加从上方坐标输入框到下方索引的同步：


已恢复上方坐标输入框的可编辑功能，并更新样式。检查是否需要其他调整：


已恢复上方坐标输入框的可编辑功能，并更新样式。修改如下：

## 完成的修改：

1. **恢复上方坐标输入框的可编辑功能**：
   - 移除了 `readOnly` 属性
   - 恢复了 `onChange`、`onBlur`、`onKeyDown` 事件处理
   - 输入坐标后按 Enter 或失去焦点时会调用 `commitCoord` 更新索引

2. **更新坐标输入框样式**：
   - 添加了 `border: 1px solid var(--border)`（浅灰色边框）
   - 背景改为 `white`
   - 光标改为 `text`
   - 添加了 `:focus` 状态样式（聚焦时边框变深，有阴影）

3. **同步机制**：
   - 编辑上方坐标 → `commitCoord` → 更新索引 → `useEffect` 同步下方输入框
   - 编辑下方输入框 → `handleSliceInputChange` → 更新索引 → `useEffect` 同步上方坐标
   - 点击图片或按钮 → 更新索引 → `useEffect` 同步上下方

现在上方坐标输入框可编辑，样式与图片一致，上下方坐标会同步。

修改已完成，没有 lint 错误。

---

**User**

@messageImage_1761925726517.jpg 做成跟這個圖片一樣的版面配置@NiiViewer.css @NiiViewer.jsx 

---

**Cursor**


查看当前代码结构，对照图片调整布局：


根据图片调整布局：将控制项合并到同一行，并调整大脑视图的网格布局。


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* map generation params */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
          <span>Gaussian FWHM:</span>
          <input 
            type="number" 
            step="0.5" 
            value={fwhm} 
            onChange={e=>setFwhm(Number(e.target.value)||0)} 
            className="nii-viewer__input"
            style={{ width: '112px', marginTop: '4px' }}
          />
        </label>
      </div>

      {/* overlay controls */}
      <div className="nii-viewer__section">
        <label className="nii-viewer__label">
          <span>Overlay alpha</span>
          <input 
            type="range" 
            min={0} 
            max={1} 
            step={0.05} 
            value={overlayAlpha} 
            onChange={e=>setOverlayAlpha(Number(e.target.value))} 
            className="nii-viewer__input"
            style={{ width: '160px' }}
          />
        </label>
      </div>
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

调整 skeleton-grid 的布局，并确保响应式布局正确：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: var(--muted);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}
```

将 skeleton grid 调整为 2x2（4 个占位符），并添加一个占位符给下载按钮位置：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

检查并优化样式，确保布局与图片一致：


清理不再使用的 CSS，并优化 header 样式：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: white;
  color: var(--fg);
  font-weight: 600;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已根据图片调整布局：

## 完成的修改：

1. **Header 简化**：
   - 仅显示 "NIfTI Viewer" 标题
   - 移除右上角的下载按钮

2. **控制面板重组**：
   - 合并为一个 section，包含两行：
     - **第一行**：Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha（水平排列）
     - **第二行**：X, Y, Z 坐标输入框

3. **大脑视图网格布局**：
   - 从 3 列改为 2x2 网格
   - 左上：Coronal (Y)
   - 右上：Sagittal (X)
   - 左下：Axial (Z)
   - 右下：Download map 按钮

4. **下载按钮位置**：
   - 移到右下角（grid 的第 4 个位置）
   - 使用 `nii-viewer__grid-download` 容器，右对齐并底部对齐

布局已与图片一致。所有修改已完成，没有 lint 错误。

---

**User**

刪除Tip: Click to lock the cross.文字

---

**Cursor**


删除 "Tip: Click to lock the cross." 提示文字：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

已刪除 "Tip: Click to lock the cross." 提示文字。修改完成，沒有 lint 錯誤。

---

**User**

恢復這行字好了

---

**Cursor**


恢复 "Tip: Click to lock the cross." 提示文字：


```javascriptreact
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(xx, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

已恢復 "Tip: Click to lock the cross." 提示文字。修改完成，沒有 lint 錯誤。

---

**User**

Sagittal (X) 底下圖片幫我左右翻轉

---

**Cursor**


查看代码，了解如何翻转 Sagittal (X) 视图的图片：


修改代码，使 Sagittal (X) 视图左右翻转：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(xx, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, iy))
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

已修改代码，將 Sagittal (X) 視圖的圖片左右翻轉。

## 完成的修改：

1. **圖像渲染翻轉**：
   - 在繪製循環中，針對 `axis === 'x'` (Sagittal 視圖) 將 X 座標翻轉
   - 使用 `srcX = (w - 1 - xx)` 而不是 `xx` 來讀取像素數據

2. **十字準線位置調整**：
   - 同步調整十字準線的 X 位置，使其與翻轉後的圖像對齊
   - 使用 `cx = w - 1 - iy` 來計算翻轉後的十字準線位置

現在 Sagittal (X) 視圖的圖片已左右翻轉，十字準線位置也已同步調整。修改完成，沒有 lint 錯誤。

---

**User**

滑鼠對應到的十字準線是相反的 幫我檢查

---

**Cursor**


检查鼠标交互逻辑，确保十字准线位置正确：


修复鼠标交互逻辑：图像已翻转，需要将屏幕坐标翻转以匹配正确的索引：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      setIy(x)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact
  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }
```

重新读取文件，检查并修复鼠标移动的处理：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], inputValue: iyInput, setInputValue: setIyInput },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], inputValue: ixInput, setInputValue: setIxInput },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], inputValue: izInput, setInputValue: setIzInput },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

已修正鼠标交互逻辑：Sagittal (X) 视图的十字准线位置现在与鼠标位置一致。

## 修复内容：

1. **`onCanvasClick` 函数**：
   - 在 `axis === 'x'` (Sagittal) 时，将鼠标 X 坐标翻转：`flippedX = canvas.width - 1 - x`
   - 使用翻转后的坐标设置 `iy`，使其与翻转后的图像对齐

2. **`onCanvasMouseMove` 函数**：
   - 同样在 `axis === 'x'` 时翻转鼠标 X 坐标
   - 确保鼠标移动时十字准线位置正确

现在 Sagittal (X) 视图的鼠标交互与翻转后的图像对齐，十字准线会跟随鼠标位置正确显示。修改完成，没有 lint 错误。

---

**User**

@NiiViewer.css @NiiViewer.jsx 三張圖片底下的座標要跟上面使用者輸入的座標一模一樣 然後不可手動更改

---

**Cursor**


修改代码，使图片下方显示与上方输入的 X、Y、Z（mm）坐标一致，并设为只读：


修改代码，使图片下方显示 mm 坐标，并与上方输入框同步：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, inputValue, setInputValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="number"
                  min="0"
                  max={max}
                  value={inputValue}
                  onChange={(e) => handleSliceInputChange(key, e.target.value)}
                  onBlur={() => commitSliceIndex(key)}
                  onKeyDown={(e) => { if(e.key === 'Enter') { commitSliceIndex(key); e.target.blur() } }}
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '3ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: var(--bg-light);
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
}

/* Hide number input spinner arrows */
.nii-viewer__slice-input::-webkit-inner-spin-button,
.nii-viewer__slice-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.nii-viewer__slice-input {
  -moz-appearance: textfield;
  appearance: textfield;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

清理不再需要的 CSS 规则：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: var(--bg-light);
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已完成修改：三张图片下方的坐标显示与上方输入的坐标一致，且不可手动更改。

## 完成的修改：

1. **修改 `sliceConfigs`**：
   - 将 `inputValue` 和 `setInputValue` 改为 `coordValue`
   - 使用 `cx`, `cy`, `cz`（mm 坐标）而不是索引值

2. **更新下方输入框**：
   - 改为显示 `coordValue`（mm 坐标）
   - 添加 `readOnly` 属性，禁止手动编辑
   - 移除 `onChange`, `onBlur`, `onKeyDown` 事件处理器
   - 将类型从 `number` 改为 `text`（支持小数）
   - 调整宽度为 `6ch` 以容纳坐标值

3. **更新 CSS 样式**：
   - 背景色改为 `var(--bg-light)`，表示只读
   - 光标改为 `default`
   - 移除 focus 时的阴影效果
   - 删除不再需要的数字输入框 spinner 样式

现在三张图片下方的坐标显示与上方输入的 X、Y、Z（mm）坐标一致，且为只读。修改完成，没有 lint 错误。

---

**User**

座標的背景不用灰色 透明就好

---

**Cursor**


将坐标输入框的背景设为透明：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已將座標輸入框的背景改為透明。已將 `background: var(--bg-light)` 改為 `background: transparent`。修改完成，沒有 lint 錯誤。

---

**User**

用Advance按鈕把Threshold mode和他的數值, Gaussian FWHM, Overlay alpha   這四個東西包起來 按下去可以顯示或隱藏資訊



---

**Cursor**


添加 "Advance" 按钮，用于显示/隐藏这些控件：


添加 "Advance" 按钮，用于显示/隐藏这些控件：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <button
          className="nii-viewer__advance-button"
          onClick={() => setShowAdvanced(!showAdvanced)}
        >
          Advance
        </button>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        <div className="nii-viewer__controls-row-top">
          <div className="nii-viewer__label">
            <span>Threshold mode</span>
            <div className="nii-viewer__mode-buttons">
              <button
                className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('value')}
              >
                Value
              </button>
              <button
                className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                onClick={() => setThrMode('pctl')}
              >
                Percentile
              </button>
            </div>
          </div>
          {thrMode === 'value' ? (
            <label className="nii-viewer__label">
              <span>Threshold</span>
              <input 
                type="number" 
                step="0.01" 
                value={thrValue} 
                onChange={e=>setThrValue(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
          ) : (
            <label className="nii-viewer__label">
              <span>Percentile</span>
              <input 
                type="number" 
                min={50} 
                max={99.9} 
                step={0.5} 
                value={pctl} 
                onChange={e=>setPctl(Number(e.target.value)||95)} 
                className="nii-viewer__input"
                style={{ width: '96px' }}
              />
            </label>
          )}
          <label className="nii-viewer__label">
            <span>Gaussian FWHM:</span>
            <input 
              type="number" 
              step="0.5" 
              value={fwhm} 
              onChange={e=>setFwhm(Number(e.target.value)||0)} 
              className="nii-viewer__input"
              style={{ width: '112px' }}
            />
          </label>
          <label className="nii-viewer__label">
            <span>Overlay alpha</span>
            <input 
              type="range" 
              min={0} 
              max={1} 
              step={0.05} 
              value={overlayAlpha} 
              onChange={e=>setOverlayAlpha(Number(e.target.value))} 
              className="nii-viewer__input"
              style={{ width: '160px' }}
            />
          </label>
        </div>

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <button
          className="nii-viewer__advance-button"
          onClick={() => setShowAdvanced(!showAdvanced)}
        >
          Advance
        </button>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        {showAdvanced && (
          <div className="nii-viewer__controls-row-top">
            <div className="nii-viewer__label">
              <span>Threshold mode</span>
              <div className="nii-viewer__mode-buttons">
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('value')}
                >
                  Value
                </button>
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('pctl')}
                >
                  Percentile
                </button>
              </div>
            </div>
            {thrMode === 'value' ? (
              <label className="nii-viewer__label">
                <span>Threshold</span>
                <input 
                  type="number" 
                  step="0.01" 
                  value={thrValue} 
                  onChange={e=>setThrValue(Number(e.target.value))} 
                  className="nii-viewer__input"
                  style={{ width: '112px' }}
                />
              </label>
            ) : (
              <label className="nii-viewer__label">
                <span>Percentile</span>
                <input 
                  type="number" 
                  min={50} 
                  max={99.9} 
                  step={0.5} 
                  value={pctl} 
                  onChange={e=>setPctl(Number(e.target.value)||95)} 
                  className="nii-viewer__input"
                  style={{ width: '96px' }}
                />
              </label>
            )}
            <label className="nii-viewer__label">
              <span>Gaussian FWHM:</span>
              <input 
                type="number" 
                step="0.5" 
                value={fwhm} 
                onChange={e=>setFwhm(Number(e.target.value)||0)} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <label className="nii-viewer__label">
              <span>Overlay alpha</span>
              <input 
                type="range" 
                min={0} 
                max={1} 
                step={0.05} 
                value={overlayAlpha} 
                onChange={e=>setOverlayAlpha(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '160px' }}
              />
            </label>
          </div>
        )}

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已添加 "Advance" 按钮，用于显示/隐藏这些控件：

## 完成的修改：

1. **添加状态管理**：
   - 添加 `showAdvanced` state，默认值为 `false`（隐藏）

2. **添加 Advance 按钮**：
   - 在 header 右侧添加 "Advance" 按钮
   - 点击切换 `showAdvanced` 状态

3. **条件渲染高级控件**：
   - 用 `{showAdvanced && (...)}` 包裹以下控件：
     - Threshold mode 和它的数值（Value/Percentile）
     - Gaussian FWHM
     - Overlay alpha

4. **样式更新**：
   - 添加 `.nii-viewer__advance-button` 样式
   - 更新 header 布局，使用 `justify-content: space-between` 让标题和按钮分布在两端

点击 "Advance" 按钮可显示/隐藏这四个高级控件。修改完成，没有 lint 错误。

---

**User**

把download map 按鈕放到advance左邊

---

**Cursor**


将 "Download map" 按钮移到 header 中，放在 "Advance" 按钮的左边：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
          <button
            className="nii-viewer__advance-button"
            onClick={() => setShowAdvanced(!showAdvanced)}
          >
            Advance
          </button>
        </div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        {showAdvanced && (
          <div className="nii-viewer__controls-row-top">
            <div className="nii-viewer__label">
              <span>Threshold mode</span>
              <div className="nii-viewer__mode-buttons">
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('value')}
                >
                  Value
                </button>
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('pctl')}
                >
                  Percentile
                </button>
              </div>
            </div>
            {thrMode === 'value' ? (
              <label className="nii-viewer__label">
                <span>Threshold</span>
                <input 
                  type="number" 
                  step="0.01" 
                  value={thrValue} 
                  onChange={e=>setThrValue(Number(e.target.value))} 
                  className="nii-viewer__input"
                  style={{ width: '112px' }}
                />
              </label>
            ) : (
              <label className="nii-viewer__label">
                <span>Percentile</span>
                <input 
                  type="number" 
                  min={50} 
                  max={99.9} 
                  step={0.5} 
                  value={pctl} 
                  onChange={e=>setPctl(Number(e.target.value)||95)} 
                  className="nii-viewer__input"
                  style={{ width: '96px' }}
                />
              </label>
            )}
            <label className="nii-viewer__label">
              <span>Gaussian FWHM:</span>
              <input 
                type="number" 
                step="0.5" 
                value={fwhm} 
                onChange={e=>setFwhm(Number(e.target.value)||0)} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <label className="nii-viewer__label">
              <span>Overlay alpha</span>
              <input 
                type="range" 
                min={0} 
                max={1} 
                step={0.05} 
                value={overlayAlpha} 
                onChange={e=>setOverlayAlpha(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '160px' }}
              />
            </label>
          </div>
        )}

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
          {/* Download button in bottom-right corner */}
          <div className="nii-viewer__grid-download">
            {query && (
              <a 
                href={mapUrl} 
                className="nii-viewer__download-link"
                download
              >
                Download map
              </a>
            )}
          </div>
        </div>
      )}
    </div>
  )
}

```

移除 grid-download 中的按钮，并更新 CSS：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
          <button
            className="nii-viewer__advance-button"
            onClick={() => setShowAdvanced(!showAdvanced)}
          >
            Advance
          </button>
        </div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        {showAdvanced && (
          <div className="nii-viewer__controls-row-top">
            <div className="nii-viewer__label">
              <span>Threshold mode</span>
              <div className="nii-viewer__mode-buttons">
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('value')}
                >
                  Value
                </button>
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('pctl')}
                >
                  Percentile
                </button>
              </div>
            </div>
            {thrMode === 'value' ? (
              <label className="nii-viewer__label">
                <span>Threshold</span>
                <input 
                  type="number" 
                  step="0.01" 
                  value={thrValue} 
                  onChange={e=>setThrValue(Number(e.target.value))} 
                  className="nii-viewer__input"
                  style={{ width: '112px' }}
                />
              </label>
            ) : (
              <label className="nii-viewer__label">
                <span>Percentile</span>
                <input 
                  type="number" 
                  min={50} 
                  max={99.9} 
                  step={0.5} 
                  value={pctl} 
                  onChange={e=>setPctl(Number(e.target.value)||95)} 
                  className="nii-viewer__input"
                  style={{ width: '96px' }}
                />
              </label>
            )}
            <label className="nii-viewer__label">
              <span>Gaussian FWHM:</span>
              <input 
                type="number" 
                step="0.5" 
                value={fwhm} 
                onChange={e=>setFwhm(Number(e.target.value)||0)} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <label className="nii-viewer__label">
              <span>Overlay alpha</span>
              <input 
                type="range" 
                min={0} 
                max={1} 
                step={0.05} 
                value={overlayAlpha} 
                onChange={e=>setOverlayAlpha(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '160px' }}
              />
            </label>
          </div>
        )}

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div className="nii-viewer__grid-download"></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

```

```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 13px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

检查并清理 skeleton-grid 中不再需要的 grid-download：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
          <button
            className="nii-viewer__advance-button"
            onClick={() => setShowAdvanced(!showAdvanced)}
          >
            Advance
          </button>
        </div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        {showAdvanced && (
          <div className="nii-viewer__controls-row-top">
            <div className="nii-viewer__label">
              <span>Threshold mode</span>
              <div className="nii-viewer__mode-buttons">
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('value')}
                >
                  Value
                </button>
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('pctl')}
                >
                  Percentile
                </button>
              </div>
            </div>
            {thrMode === 'value' ? (
              <label className="nii-viewer__label">
                <span>Threshold</span>
                <input 
                  type="number" 
                  step="0.01" 
                  value={thrValue} 
                  onChange={e=>setThrValue(Number(e.target.value))} 
                  className="nii-viewer__input"
                  style={{ width: '112px' }}
                />
              </label>
            ) : (
              <label className="nii-viewer__label">
                <span>Percentile</span>
                <input 
                  type="number" 
                  min={50} 
                  max={99.9} 
                  step={0.5} 
                  value={pctl} 
                  onChange={e=>setPctl(Number(e.target.value)||95)} 
                  className="nii-viewer__input"
                  style={{ width: '96px' }}
                />
              </label>
            )}
            <label className="nii-viewer__label">
              <span>Gaussian FWHM:</span>
              <input 
                type="number" 
                step="0.5" 
                value={fwhm} 
                onChange={e=>setFwhm(Number(e.target.value)||0)} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <label className="nii-viewer__label">
              <span>Overlay alpha</span>
              <input 
                type="range" 
                min={0} 
                max={1} 
                step={0.05} 
                value={overlayAlpha} 
                onChange={e=>setOverlayAlpha(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '160px' }}
              />
            </label>
          </div>
        )}

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z (mm):</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

```

已将 "Download map" 按钮移到 header 中，放在 "Advance" 按钮的左边。

## 完成的修改：

1. **移动 Download map 按钮**：
   - 从网格右下角移到 header
   - 放在 "Advance" 按钮的左边

2. **添加容器**：
   - 创建 `nii-viewer__header-actions` 容器
   - 包含 "Download map" 和 "Advance" 按钮
   - 使用 `gap: 8px` 设置间距

3. **清理代码**：
   - 移除网格中的 `grid-download` 容器
   - 在 skeleton grid 中改为空 div 占位

现在 "Download map" 按钮显示在 header 右侧，"Advance" 按钮的左边。修改完成，没有 lint 错误。

---

**User**

X(mm):改成X就好 y,z以此類推

---

**Cursor**


将坐标输入框的标签从 "X (mm):" 改为 "X:"，Y 和 Z 同样处理：


```javascriptreact

// 顯示設定：讓 x>0 出現在畫面右側（右腦在右）
const X_RIGHT_ON_SCREEN_RIGHT = true;

import { useEffect, useMemo, useRef, useState } from 'react'
import './NiiViewer.css'
import * as nifti from 'nifti-reader-js'

const MNI_BG_URL = 'static/mni_2mm.nii.gz'

// Detect MNI152 2mm template dims & spacing (91x109x91, 2mm iso)
function isStandardMNI2mm(dims, voxelMM) {
  const okDims = Array.isArray(dims) && dims[0]===91 && dims[1]===109 && dims[2]===91;
  const okSp   = voxelMM && Math.abs(voxelMM[0]-2)<1e-3 && Math.abs(voxelMM[1]-2)<1e-3 && Math.abs(voxelMM[2]-2)<1e-3;
  return okDims && okSp;
}
// Standard MNI152 2mm affine (voxel i,j,k -> MNI mm):
// x = -2*i + 90;  y = 2*j - 126;  z = 2*k - 72
const MNI2MM = { x0: 90, y0: -126, z0: -72, vx: 2, vy: 2, vz: 2 };

export function NiiViewer({ query }) {
  const [loadingBG, setLoadingBG] = useState(false)
  const [loadingMap, setLoadingMap] = useState(false)
  const [errBG, setErrBG] = useState('')
  const [errMap, setErrMap] = useState('')

  // backend params (map generation)
  const [voxel, setVoxel] = useState(2.0)
  const [fwhm, setFwhm] = useState(10.0)
  const [kernel, setKernel] = useState('gauss')
  const [r, setR] = useState(6.0)

  // overlay controls
  const [overlayAlpha, setOverlayAlpha] = useState(0.5)
  const [posOnly, setPosOnly] = useState(true)
  const [useAbs, setUseAbs] = useState(false)
  const [thrMode, setThrMode] = useState('pctl') // default: Percentile (per request)
  const [pctl, setPctl] = useState(95)
  const [thrValue, setThrValue] = useState(0.05)     // used when mode === 'value'

  // volumes
  const bgRef  = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const mapRef = useRef(null)   // { data, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min, max }
  const getVoxelMM = () => {
    const vm = bgRef.current?.voxelMM ?? mapRef.current?.voxelMM ?? [1,1,1]
    return { x: vm[0], y: vm[1], z: vm[2] }
  }
  const [dims, setDims] = useState([0,0,0]) // canvas dims (prefer BG; overlay only if same dims)

  // slice indices (voxel coordinates in [0..N-1])
  const [ix, setIx] = useState(0) // sagittal (X)
  const [iy, setIy] = useState(0) // coronal  (Y)
  const [iz, setIz] = useState(0) // axial    (Z)

  // track if crosshairs are locked (fixed) for each axis
  const [lockedAxes, setLockedAxes] = useState({ x: false, y: false, z: false })

  // show/hide advanced controls
  const [showAdvanced, setShowAdvanced] = useState(false)

  // input values for slice indices (for editing below images)
  const [ixInput, setIxInput] = useState('0')
  const [iyInput, setIyInput] = useState('0')
  const [izInput, setIzInput] = useState('0')

  // Neurosynth-style displayed coords: signed, centered at middle voxel
  const [cx, setCx] = useState('0')
  const [cy, setCy] = useState('0')
  const [cz, setCz] = useState('0')

  const canvases = [useRef(null), useRef(null), useRef(null)]

  const mapUrl = useMemo(() => {
    if (!query) return ''
    const u = new URL(`/query/${encodeURIComponent(query)}/nii`, window.location.origin)
    u.searchParams.set('voxel', String(voxel))
    u.searchParams.set('fwhm', String(fwhm))
    u.searchParams.set('kernel', String(kernel))
    u.searchParams.set('r', String(r))
    return u.pathname + u.search
  }, [query, voxel, fwhm, kernel, r])

  // ---------- utils ----------
  function asTypedArray (header, buffer) {
    switch (header.datatypeCode) {
      case nifti.NIFTI1.TYPE_INT8:    return new Int8Array(buffer)
      case nifti.NIFTI1.TYPE_UINT8:   return new Uint8Array(buffer)
      case nifti.NIFTI1.TYPE_INT16:   return new Int16Array(buffer)
      case nifti.NIFTI1.TYPE_UINT16:  return new Uint16Array(buffer)
      case nifti.NIFTI1.TYPE_INT32:   return new Int32Array(buffer)
      case nifti.NIFTI1.TYPE_UINT32:  return new Uint32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT32: return new Float32Array(buffer)
      case nifti.NIFTI1.TYPE_FLOAT64: return new Float64Array(buffer)
      default: return new Float32Array(buffer)
    }
  }
  function minmax (arr) {
    let mn =  Infinity, mx = -Infinity
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i]
      if (v < mn) mn = v
      if (v > mx) mx = v
    }
    return [mn, mx]
  }
  function percentile(arr, p, step=Math.ceil(arr.length/200000)) {
    if (!arr.length) return 0
    const samp = []
    for (let i=0; i<arr.length; i+=step) samp.push(arr[i])
    samp.sort((a,b)=>a-b)
    const k = Math.floor((p/100) * (samp.length - 1))
    return samp[Math.max(0, Math.min(samp.length-1, k))]
  }
  async function loadNifti(url) {
    const res = await fetch(url)
    if (!res.ok) {
      const t = await res.text().catch(()=> '')
      throw new Error(`GET ${url} → ${res.status} ${t}`)
    }
    let ab = await res.arrayBuffer()
    if (nifti.isCompressed(ab)) ab = nifti.decompress(ab)
    if (!nifti.isNIFTI(ab)) throw new Error('not a NIfTI file')
    const header = nifti.readHeader(ab)
    const image  = nifti.readImage(header, ab)
    const ta     = asTypedArray(header, image)
    let f32
    if (ta instanceof Float32Array) f32 = ta
    else if (ta instanceof Float64Array) f32 = Float32Array.from(ta)
    else {
      const [mn, mx] = minmax(ta)
      const range = (mx - mn) || 1
      f32 = new Float32Array(ta.length)
      for (let i=0;i<ta.length;i++) f32[i] = (ta[i] - mn) / range
    }
    const nx = header.dims[1] | 0
    const ny = header.dims[2] | 0
    const nz = header.dims[3] | 0
    if (!nx || !ny || !nz) throw new Error('invalid dims')
    const [mn, mx] = minmax(f32)
    const vx = Math.abs(header.pixDims?.[1] ?? 1)
    const vy = Math.abs(header.pixDims?.[2] ?? 1)
    const vz = Math.abs(header.pixDims?.[3] ?? 1)
    return { data: f32, dims:[nx,ny,nz], voxelMM:[vx,vy,vz], min: mn, max: mx }
  }

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))

  // helpers: convert between index [0..N-1] and neurosynth-style signed coord centered at mid voxel
  // Display conventions to match Neurosynth-like UI:
  //  - X: right-positive
  //  - Y: anterior-positive (but screen vertical is flipped), so invert sign
  //  - Z: superior-positive (also vertical), invert sign
  const AXIS_SIGN = { x: -1, y: 1, z: 1 } // X is neg for index<->coord mapping only when not using standard MNI affine
  const idx2coord = (i, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      if (axis === 'x') return (-MNI2MM.vx * i + MNI2MM.x0);
      if (axis === 'y') return ( MNI2MM.vy * i + MNI2MM.y0);
      if (axis === 'z') return ( MNI2MM.vz * i + MNI2MM.z0);
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    return AXIS_SIGN[axis] * (i - Math.floor(n/2)) * mmPerVoxel;
  }
const coord2idx = (c_mm, n, axis) => {
    const [nx, ny, nz] = dims;
    const { x: vx, y: vy, z: vz } = getVoxelMM();
    const isStd = isStandardMNI2mm([nx, ny, nz], [vx, vy, vz]);
    if (isStd) {
      let v;
      if (axis === 'x') v = ( (MNI2MM.x0 - c_mm) / MNI2MM.vx );
      else if (axis === 'y') v = ( (c_mm - MNI2MM.y0) / MNI2MM.vy );
      else v = ( (c_mm - MNI2MM.z0) / MNI2MM.vz );
      const idx = Math.round(v);
      return Math.max(0, Math.min(n-1, idx));
    }
    const mmPerVoxel = axis === 'x' ? vx : axis === 'y' ? vy : vz;
    const sign = AXIS_SIGN[axis];
    const v = (sign * (c_mm / mmPerVoxel)) + Math.floor(n/2);
    const idx = Math.round(v);
    return Math.max(0, Math.min(n-1, idx));
  }
  // load background on mount
  useEffect(() => {
    let alive = true
    setLoadingBG(true); setErrBG('')
    ;(async () => {
      try {
        const bg = await loadNifti(MNI_BG_URL)
        if (!alive) return
        bgRef.current = bg
        // Always prefer BG dims for the canvas
        setDims(bg.dims)
        const [nx,ny,nz] = bg.dims
        const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
        setIx(mx); setIy(my); setIz(mz)
      } catch (e) {
        if (!alive) return
        setErrBG(e?.message || String(e))
        bgRef.current = null
      } finally {
        if (!alive) return
        setLoadingBG(false)
      }
    })()
    return () => { alive = false }
  }, [])

  
  // keep thrValue within current map range when map changes
  useEffect(() => {
    const mn = mapRef.current?.min ?? 0
    const mx = mapRef.current?.max ?? 1
    if (thrValue < mn || thrValue > mx) {
      setThrValue(Math.min(mx, Math.max(mn, thrValue)))
    }
  }, [mapRef.current, dims])

  // ensure thrValue defaults to 0.05 when switching to value mode
  useEffect(() => {
    if (thrMode === 'value' && thrValue === 0) {
      setThrValue(0.05)
    }
  }, [thrMode])

// load meta-analytic map when query/params change
  useEffect(() => {
    if (!mapUrl) { mapRef.current = null; return }
    let alive = true
    setLoadingMap(true); setErrMap('')
    ;(async () => {
      try {
        const mv = await loadNifti(mapUrl)
        if (!alive) return
        mapRef.current = mv
        if (!bgRef.current) {
          setDims(mv.dims)
          const [nx,ny,nz] = mv.dims
          const mx = Math.floor(nx/2), my = Math.floor(ny/2), mz = Math.floor(nz/2)
          setIx(mx); setIy(my); setIz(mz)
        }
      } catch (e) {
        if (!alive) return
        setErrMap(e?.message || String(e))
        mapRef.current = null
      } finally {
        if (!alive) return
        setLoadingMap(false)
      }
    })()
    return () => { alive = false }
  }, [mapUrl])

  const mapThreshold = useMemo(() => {
    const mv = mapRef.current
    if (!mv) return null
    if (thrMode === 'value') return Number(thrValue) || 0
    return percentile(mv.data, Math.max(0, Math.min(100, Number(pctl) || 95)))
  }, [thrMode, thrValue, pctl, mapRef.current])

  // draw one slice (upright orientation via vertical flip)
  function drawSlice (canvas, axis /* 'z' | 'y' | 'x' */, index) {
    const [nx, ny, nz] = dims
    
    // 若要讓 x>0 出現在畫面右側，就在取樣時把 X 軸做水平翻轉
    const sx = (x) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - x) : x);
    const bg  = bgRef.current
    const map = mapRef.current

    const dimsStr = dims.join('x')
    const bgOK  = !!(bg  && bg.dims.join('x')  === dimsStr)
    const mapOK = !!(map && map.dims.join('x') === dimsStr)

    let w=0, h=0, getBG=null, getMap=null
    if (axis === 'z') { w = nx; h = ny; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + y*nx + index*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + y*nx + index*nx*ny] }
    if (axis === 'y') { w = nx; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[sx(x) + index*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[sx(x) + index*nx + y*nx*ny] }
    if (axis === 'x') { w = ny; h = nz; if (bgOK)  getBG  = (x,y)=> bg.data[index + x*nx + y*nx*ny]; if (mapOK) getMap = (x,y)=> map.data[index + x*nx + y*nx*ny] }

    canvas.width = w; canvas.height = h
    const ctx = canvas.getContext('2d', { willReadFrequently: false })
    const img = ctx.createImageData(w, h)

    const alpha = Math.max(0, Math.min(1, overlayAlpha))
    const R = 255, G = 0, B = 0
    const thr = mapThreshold

    // background normalization based on its own min/max
    const bgMin = bg?.min ?? 0
    const bgMax = bg?.max ?? 1
    const bgRange = (bgMax - bgMin) || 1

    let p = 0
    for (let yy=0; yy<h; yy++) {
      const srcY = h - 1 - yy // flip vertically
      for (let xx=0; xx<w; xx++) {
        // For Sagittal (X) view, flip horizontally
        const srcX = (axis === 'x') ? (w - 1 - xx) : xx
        // draw background
        let gray = 0
        if (getBG) {
          const vbg = getBG(srcX, srcY)
          let g = (vbg - bgMin) / bgRange
          if (g < 0) g = 0
          if (g > 1) g = 1
          gray = (g * 255) | 0
        }
        img.data[p    ] = gray
        img.data[p + 1] = gray
        img.data[p + 2] = gray
        img.data[p + 3] = 255

        // overlay map
        if (getMap) {
          let mv = getMap(srcX, srcY)
          const raw = mv
          if (useAbs) mv = Math.abs(mv)
          let pass = (thr == null) ? (mv > 0) : (mv >= thr)
          if (posOnly && raw <= 0) pass = false
          if (pass) {
            img.data[p    ] = ((1 - alpha) * img.data[p]     + alpha * R) | 0
            img.data[p + 1] = ((1 - alpha) * img.data[p + 1] + alpha * G) | 0
            img.data[p + 2] = ((1 - alpha) * img.data[p + 2] + alpha * B) | 0
          }
        }
        p += 4
      }
    }
    ctx.putImageData(img, 0, 0)

    // draw green crosshairs
    ctx.save()
    ctx.strokeStyle = '#00ff00'
    ctx.lineWidth = 1
    let cx = 0, cy = 0
    if (axis === 'z') { // plane: X by Y
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iy))
    } else if (axis === 'y') { // plane: X by Z
      cx = Math.max(0, Math.min(w-1, (X_RIGHT_ON_SCREEN_RIGHT ? (w - 1 - ix) : ix)))
      cy = Math.max(0, Math.min(h-1, iz))
    } else { // axis === 'x' (plane: Y by Z)
      cx = Math.max(0, Math.min(w-1, w - 1 - iy)) // Flip horizontally for Sagittal view
      cy = Math.max(0, Math.min(h-1, iz))
    }
    const screenY = h - 1 - cy // account for vertical flip used when drawing
    // vertical line
    ctx.beginPath(); ctx.moveTo(cx + 0.5, 0); ctx.lineTo(cx + 0.5, h); ctx.stroke()
    // horizontal line
    ctx.beginPath(); ctx.moveTo(0, screenY + 0.5); ctx.lineTo(w, screenY + 0.5); ctx.stroke()
    ctx.restore()
  }

  // click-to-move crosshairs and lock them
  function onCanvasClick (e, axis) {
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
    
    // Lock this axis
    setLockedAxes(prev => ({ ...prev, [axis]: true }))
  }

  // mouse move to adjust crosshairs (only if not locked)
  function onCanvasMouseMove (e, axis) {
    if (lockedAxes[axis]) return // Skip if locked
    
    const canvas = e.currentTarget
    const rect = canvas.getBoundingClientRect()
    const x = Math.floor((e.clientX - rect.left) * canvas.width / rect.width)
    const y = Math.floor((e.clientY - rect.top) * canvas.height / rect.height)
    const srcY = canvas.height - 1 - y // invert because we draw with vertical flip
    const [nx,ny,nz] = dims
    
    const toIdxX = (screenX) => (X_RIGHT_ON_SCREEN_RIGHT ? (nx - 1 - screenX) : screenX);
    if (axis === 'z') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIy(srcY)
    }
    else if (axis === 'y') { 
      const xi = toIdxX(x)
      setIx(xi)
      setIz(srcY)
    }
    else { 
      // axis === 'x' (Sagittal): flip horizontally because image is flipped
      const flippedX = canvas.width - 1 - x
      setIy(flippedX)
      setIz(srcY)
    }
  }

  // unlock crosshairs when mouse enters canvas
  function onCanvasMouseEnter (e, axis) {
    setLockedAxes(prev => ({ ...prev, [axis]: false }))
  }

  // keep display coords in sync when ix/iy/iz/dims change (e.g., after loads)
  useEffect(() => {
    const [nx,ny,nz] = dims
    if (!nx) return
    
    // Ensure refs are loaded before calculating coordinates
    const bgLoaded = bgRef.current !== null
    const mapLoaded = mapRef.current !== null
    if (!bgLoaded && !mapLoaded) return
    
    // Calculate coordinates using current indices
    setCx(String(idx2coord(ix, nx, 'x')))
    setCy(String(idx2coord(iy, ny, 'y')))
    setCz(String(idx2coord(iz, nz, 'z')))
    // Sync input values
    setIxInput(String(ix))
    setIyInput(String(iy))
    setIzInput(String(iz))
  }, [ix,iy,iz,dims, loadingBG, loadingMap])

  // commit handlers: parse signed integer, map to index, clamp to volume
  const commitCoord = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? cx : axis==='y' ? cy : cz
    // allow empty / '-' temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseFloat(vStr)
    if (Number.isNaN(parsed)) return
    if (axis==='x') setIx(coord2idx(parsed, nx, 'x'))
    if (axis==='y') setIy(coord2idx(parsed, ny, 'y'))
    if (axis==='z') setIz(coord2idx(parsed, nz, 'z'))
  }

  // commit handlers for slice index inputs (below images)
  const commitSliceIndex = (axis) => {
    const [nx,ny,nz] = dims
    let vStr = axis==='x' ? ixInput : axis==='y' ? iyInput : izInput
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    // allow empty temporary states
    if (vStr === '' || vStr === '-' ) return
    const parsed = parseInt(vStr, 10)
    if (Number.isNaN(parsed)) return
    const clamped = Math.max(0, Math.min(max, parsed))
    if (axis==='x') {
      setIx(clamped)
      setIxInput(String(clamped))
    }
    if (axis==='y') {
      setIy(clamped)
      setIyInput(String(clamped))
    }
    if (axis==='z') {
      setIz(clamped)
      setIzInput(String(clamped))
    }
  }

  // Handle input change and update in real-time if valid
  const handleSliceInputChange = (axis, value) => {
    const [nx,ny,nz] = dims
    const max = axis==='x' ? nx-1 : axis==='y' ? ny-1 : nz-1
    
    if (axis==='x') {
      setIxInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIx(clamped)
      }
    }
    if (axis==='y') {
      setIyInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIy(clamped)
      }
    }
    if (axis==='z') {
      setIzInput(value)
      const parsed = parseInt(value, 10)
      if (!Number.isNaN(parsed) && value !== '' && value !== '-') {
        const clamped = Math.max(0, Math.min(max, parsed))
        setIz(clamped)
      }
    }
  }

  // redraw on state changes
  useEffect(() => {
    const [nx, ny, nz] = dims
    if (!nx) return
    const c0 = canvases[0].current, c1 = canvases[1].current, c2 = canvases[2].current
    if (c0 && iz >=0 && iz < nz) drawSlice(c0, 'z', iz)
    if (c1 && iy >=0 && iy < ny) drawSlice(c1, 'y', iy)
    if (c2 && ix >=0 && ix < nx) drawSlice(c2, 'x', ix)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    dims, ix, iy, iz,
    overlayAlpha, posOnly, useAbs, thrMode, pctl, thrValue,
    loadingBG, loadingMap, errBG, errMap, query
  ])

  const [nx, ny, nz] = dims

  // slice configs (labels only; numbers removed)
  const sliceConfigs = [
    { key: 'y', name: 'Coronal',  axisLabel: 'Y', index: iy, setIndex: setIy, max: Math.max(0, ny-1), canvasRef: canvases[1], coordValue: cy },
    { key: 'x', name: 'Sagittal', axisLabel: 'X', index: ix, setIndex: setIx, max: Math.max(0, nx-1), canvasRef: canvases[2], coordValue: cx },
    { key: 'z', name: 'Axial',    axisLabel: 'Z', index: iz, setIndex: setIz, max: Math.max(0, nz-1), canvasRef: canvases[0], coordValue: cz },
  ]

  return (
    <div className="nii-viewer">
      <div className="nii-viewer__header">
        <div className="nii-viewer__title">NIfTI Viewer</div>
        <div className="nii-viewer__header-actions">
          {query && (
            <a 
              href={mapUrl} 
              className="nii-viewer__download-link"
              download
            >
              Download map
            </a>
          )}
          <button
            className="nii-viewer__advance-button"
            onClick={() => setShowAdvanced(!showAdvanced)}
          >
            Advance
          </button>
        </div>
      </div>

      {/* --- Control Panel: All controls in one section --- */}
      <div className="nii-viewer__section">
        {/* Row 1: Threshold mode + Threshold/Percentile + Gaussian FWHM + Overlay alpha */}
        {showAdvanced && (
          <div className="nii-viewer__controls-row-top">
            <div className="nii-viewer__label">
              <span>Threshold mode</span>
              <div className="nii-viewer__mode-buttons">
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'value' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('value')}
                >
                  Value
                </button>
                <button
                  className={`nii-viewer__mode-button ${thrMode === 'pctl' ? 'nii-viewer__mode-button--active' : ''}`}
                  onClick={() => setThrMode('pctl')}
                >
                  Percentile
                </button>
              </div>
            </div>
            {thrMode === 'value' ? (
              <label className="nii-viewer__label">
                <span>Threshold</span>
                <input 
                  type="number" 
                  step="0.01" 
                  value={thrValue} 
                  onChange={e=>setThrValue(Number(e.target.value))} 
                  className="nii-viewer__input"
                  style={{ width: '112px' }}
                />
              </label>
            ) : (
              <label className="nii-viewer__label">
                <span>Percentile</span>
                <input 
                  type="number" 
                  min={50} 
                  max={99.9} 
                  step={0.5} 
                  value={pctl} 
                  onChange={e=>setPctl(Number(e.target.value)||95)} 
                  className="nii-viewer__input"
                  style={{ width: '96px' }}
                />
              </label>
            )}
            <label className="nii-viewer__label">
              <span>Gaussian FWHM:</span>
              <input 
                type="number" 
                step="0.5" 
                value={fwhm} 
                onChange={e=>setFwhm(Number(e.target.value)||0)} 
                className="nii-viewer__input"
                style={{ width: '112px' }}
              />
            </label>
            <label className="nii-viewer__label">
              <span>Overlay alpha</span>
              <input 
                type="range" 
                min={0} 
                max={1} 
                step={0.05} 
                value={overlayAlpha} 
                onChange={e=>setOverlayAlpha(Number(e.target.value))} 
                className="nii-viewer__input"
                style={{ width: '160px' }}
              />
            </label>
          </div>
        )}

        {/* Row 2: Coordinate inputs */}
        <div className="nii-viewer__controls-row">
          <label className="nii-viewer__coordinate-label">
            <span>X:</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cx}
              onChange={e=>setCx(e.target.value)}
              onBlur={()=>commitCoord('x')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('x'); e.target.blur() } }}
              aria-label="X coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Y:</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cy}
              onChange={e=>setCy(e.target.value)}
              onBlur={()=>commitCoord('y')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('y'); e.target.blur() } }}
              aria-label="Y coordinate (centered)"
            />
          </label>
          <label className="nii-viewer__coordinate-label">
            <span>Z:</span>
            <input
              type="text" 
              inputMode="decimal" 
              pattern="-?[0-9]*([.][0-9]+)?"
              className="nii-viewer__coordinate-input"
              value={cz}
              onChange={e=>setCz(e.target.value)}
              onBlur={()=>commitCoord('z')}
              onKeyDown={e=>{ if(e.key==='Enter'){ commitCoord('z'); e.target.blur() } }}
              aria-label="Z coordinate (centered)"
            />
          </label>
          <span className="nii-viewer__tip">Tip: Click to lock the cross.</span>
        </div>
      </div>

      {/* --- Brain views --- */}
      {(loadingBG || loadingMap) && (
        <div className="nii-viewer__skeleton-grid">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="nii-viewer__skeleton-item" />
          ))}
          <div></div>
        </div>
      )}
      {(errBG || errMap) && (
        <div className="nii-viewer__error">
          {errBG && <div>Background: {errBG}</div>}
          {errMap && <div>Map: {errMap}</div>}
        </div>
      )}

      {!!nx && (
        <div className="nii-viewer__grid">
          {sliceConfigs.map(({ key, name, axisLabel, index, setIndex, max, canvasRef, coordValue }) => (
            <div key={key} className="nii-viewer__slice-container">
              <div className="nii-viewer__slice-label">{name} ({axisLabel})</div>
              <canvas 
                ref={canvasRef} 
                className="nii-viewer__canvas"
                onClick={(e)=>onCanvasClick(e, key)}
                onMouseMove={(e)=>onCanvasMouseMove(e, key)}
                onMouseEnter={(e)=>onCanvasMouseEnter(e, key)}
              />
              <div className="nii-viewer__slice-controls">
                <button
                  disabled={index <= 0}
                  onClick={() => setIndex(Math.max(0, index - 1))}
                  className="nii-viewer__button"
                >
                  −
                </button>
                <input
                  type="text"
                  value={coordValue}
                  readOnly
                  className="nii-viewer__slice-input"
                  style={{ minWidth: '6ch', textAlign: 'center', fontSize: '13px' }}
                />
                <button
                  disabled={index >= max}
                  onClick={() => setIndex(Math.min(max, index + 1))}
                  className="nii-viewer__button"
                >
                  +
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

```

已將座標輸入框的標籤從 "X (mm):"、"Y (mm):"、"Z (mm):" 改為 "X:"、"Y:"、"Z:"。修改完成，沒有 lint 錯誤。

---

**User**

把xyz文字跟欄位放大、粗體、色號#004B97

---

**Cursor**


将 XYZ 文字和输入框调整为放大、粗体、颜色 #004B97：


调整 XYZ 标签和输入框样式：放大、粗体、颜色 #004B97。


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 16px;
}

.nii-viewer__coordinate-label span {
  font-weight: 700;
  color: #004B97;
  font-size: 16px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  color: #004B97;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: var(--fg-dark);
  box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

调整 focus 状态的边框颜色，使其与新的颜色主题一致：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 16px;
}

.nii-viewer__coordinate-label span {
  font-weight: 700;
  color: #004B97;
  font-size: 16px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  color: #004B97;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: #004B97;
  box-shadow: 0 0 0 2px rgba(0, 75, 151, 0.1);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 XYZ 文字和输入框调整为放大、粗体、颜色 #004B97：

## 完成的修改：

1. **坐标标签样式**：
   - 字体大小从 `13px` 增加到 `16px`
   - 标签文字（X, Y, Z）设为粗体（`font-weight: 700`）
   - 颜色设为 `#004B97`

2. **坐标输入框样式**：
   - 字体大小从 `13px` 增加到 `16px`
   - 设为粗体（`font-weight: 700`）
   - 文字颜色设为 `#004B97`

3. **Focus 状态**：
   - 边框颜色改为 `#004B97`
   - 阴影颜色调整为与主题一致

修改完成，没有 lint 错误。

---

**User**

匡線用#ECF5FF

---

**Cursor**


将坐标输入框的边框颜色改为 #ECF5FF：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 16px;
}

.nii-viewer__coordinate-label span {
  font-weight: 700;
  color: #004B97;
  font-size: 16px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid #ECF5FF;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  color: #004B97;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: #004B97;
  box-shadow: 0 0 0 2px rgba(0, 75, 151, 0.1);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将坐标输入框的边框颜色改为 `#ECF5FF`。修改完成，没有 lint 错误。

---

**User**

把Query Builder, NIfTI Viewer 最外圍的匡線刪除



---

**Cursor**


查找并移除 Query Builder 和 NIfTI Viewer 最外围的边框：


查看 App.jsx，确认如何移除这些 Card 的边框：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card--no-border {
  border: none;
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 16px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card--stack .query-builder + .card__title {
  margin-top: 32px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

在 App.jsx 中为这两个 Card 添加 `card--no-border` 类，移除边框：


```javascriptreact
import { useCallback, useRef, useState } from 'react'
import { QueryBuilder } from './components/QueryBuilder'
import { Studies } from './components/Studies'
import { NiiViewer } from './components/NiiViewer'
import { LandingPage } from './components/LandingPage'
import { AppHeader } from './components/AppHeader'
import { Terms } from './components/Terms'
import { Card, CardTitle } from './components/Card'
import { Resizer } from './components/Resizer'
import { useUrlQueryState } from './hooks/useUrlQueryState'
import './App.css'

export default function App () {
  const [showLanding, setShowLanding] = useState(true)
  const [query, setQuery] = useUrlQueryState('q')

  const handleStart = useCallback(() => {
    console.log('handleStart called, setting showLanding to false')
    setShowLanding(false)
    console.log('showLanding set to false, should render main app now')
  }, [])

  const handlePickTerm = useCallback((t) => {
    setQuery((q) => (q ? `${q} ${t}` : t))
  }, [setQuery])

  // --- resizable panes state ---
  const gridRef = useRef(null)
  const [sizes, setSizes] = useState([50, 50]) // [middle, right] - removed left pane
  const MIN_PX = 240

  const startDrag = (which, e) => {
    e.preventDefault()
    const startX = e.clientX
    const rect = gridRef.current.getBoundingClientRect()
    const total = rect.width
    const curPx = sizes.map(p => (p / 100) * total)

    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX
      if (which === 0) {
        let newMid = curPx[0] + dx
        let newRight = curPx[1] - dx
        if (newMid < MIN_PX) { newRight -= (MIN_PX - newMid); newMid = MIN_PX }
        if (newRight < MIN_PX) { newMid -= (MIN_PX - newRight); newRight = MIN_PX }
        const s1 = (newMid / total) * 100
        const s2 = (newRight / total) * 100
        setSizes([s1, Math.max(s2, 0)])
      }
    }
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove)
      window.removeEventListener('mouseup', onMouseUp)
    }
    window.addEventListener('mousemove', onMouseMove)
    window.addEventListener('mouseup', onMouseUp)
  }

  if (showLanding) {
    return <LandingPage onStart={handleStart} />
  }

  console.log('Rendering main app, query:', query, 'showLanding:', showLanding)

  return (
    <div className="app">
      <AppHeader onLogoClick={() => setShowLanding(true)} />
      
      <div className="app__terms-section">
        <Terms onPickTerm={handlePickTerm} />
      </div>

      <main className="app__grid" ref={gridRef}>
        <Card className="card--stack card--no-border" style={{ flexBasis: `${sizes[0]}%` }}>
          <CardTitle>Query Builder</CardTitle>
          <QueryBuilder query={query} setQuery={setQuery} />
          <CardTitle>Studies</CardTitle>
          <Studies query={query} />
        </Card>

        <Resizer 
          ariaLabel="Resize middle/right" 
          onMouseDown={(e) => startDrag(0, e)} 
        />

        <Card className="card--no-border" style={{ flexBasis: `${sizes[1]}%` }}>
          <NiiViewer query={query} />
        </Card>
      </main>
    </div>
  )
}

```

已移除 Query Builder 和 NIfTI Viewer 最外围的边框：

## 完成的修改：

1. **在 Card.css 中添加样式**：
   - 添加 `.card--no-border` 类，设置 `border: none` 移除边框

2. **在 App.jsx 中应用样式**：
   - 为 Query Builder 的 Card 添加 `card--no-border` 类
   - 为 NIfTI Viewer 的 Card 添加 `card--no-border` 类

现在这两个组件的最外围边框已移除。修改完成，没有 lint 错误。

---

**User**

把Query Builder, NIfTI Viewer 文字放大

---

**Cursor**


放大 "Query Builder" 和 "NIfTI Viewer" 标题：


```css
.card {
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow-sm);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card--no-border {
  border: none;
}

.card:hover {
  box-shadow: var(--shadow-md);
  transform: translateY(-1px);
}

.card--stack {
  display: flex;
  flex-direction: column;
}

.card__title {
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 20px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
}

.card--stack .query-builder + .card__title {
  margin-top: 32px;
}

.card__divider {
  height: 1px;
  background: linear-gradient(to right, transparent, var(--border), transparent);
  margin: 16px 0;
}


```

检查并调整 NIfTI Viewer 标题的字体大小：


```css
.nii-viewer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.nii-viewer__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.nii-viewer__header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nii-viewer__advance-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__advance-button:hover {
  background: var(--border);
}

.nii-viewer__title {
  font-weight: 700;
  font-size: 20px;
  color: var(--fg-dark);
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 0;
}

.nii-viewer__input[type="range"] {
  width: 160px;
}

.nii-viewer__download-link {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  color: var(--fg);
  background: #FFD2D2;
  text-decoration: none;
  transition: all 0.2s ease;
}

.nii-viewer__download-link:hover {
  background: #FF9797;
  color: var(--fg-dark);
}

.nii-viewer__section {
  border: none;
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
}

.nii-viewer__label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 8px;
}

.nii-viewer__threshold-row .nii-viewer__label {
  margin-bottom: 0;
}

.nii-viewer__select,
.nii-viewer__input {
  padding: 6px 8px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.nii-viewer__select:focus,
.nii-viewer__input:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
}

.nii-viewer__controls-row-top {
  display: flex;
  align-items: center;
  gap: 24px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

.nii-viewer__controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nii-viewer__tip {
  margin-left: auto;
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
}

.nii-viewer__coordinate-label {
  display: flex;
  align-items: center;
  font-size: 16px;
}

.nii-viewer__coordinate-label span {
  font-weight: 700;
  color: #004B97;
  font-size: 16px;
}

.nii-viewer__coordinate-input {
  width: 80px;
  padding: 4px 8px;
  border: 1px solid #ECF5FF;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  color: #004B97;
  margin-left: 4px;
  background: white;
  cursor: text;
}

.nii-viewer__coordinate-input:focus {
  outline: none;
  border-color: #004B97;
  box-shadow: 0 0 0 2px rgba(0, 75, 151, 0.1);
}

.nii-viewer__grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__grid-download {
  display: flex;
  align-items: flex-end;
  justify-content: flex-end;
  padding: 8px;
}

.nii-viewer__skeleton-grid {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows: repeat(2, auto);
}

.nii-viewer__skeleton-item {
  height: 256px;
  animation: pulse 1.5s ease-in-out infinite;
  border-radius: 12px;
  border: none;
  background: var(--bg-light);
}

.nii-viewer__error {
  border-radius: 8px;
  border: none;
  background: #fee;
  padding: 12px;
  font-size: 13px;
  color: #c33;
}

.nii-viewer__slice-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.nii-viewer__slice-label {
  font-size: 12px;
  color: var(--muted);
}

.nii-viewer__slice-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nii-viewer__slice-input {
  padding: 4px 6px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  text-align: center;
  background: transparent;
  color: var(--fg);
  font-weight: 600;
  cursor: default;
}

.nii-viewer__slice-input:focus {
  outline: none;
  box-shadow: none;
}

.nii-viewer__canvas {
  width: 100%;
  height: 256px;
  border-radius: 12px;
  border: none;
  cursor: crosshair;
}

.nii-viewer__button {
  padding: 4px 8px;
  background: var(--fg-dark);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__button:hover {
  background: var(--muted);
}

.nii-viewer__button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.nii-viewer__mode-buttons {
  display: flex;
  gap: 8px;
}

.nii-viewer__mode-button {
  padding: 6px 12px;
  background: var(--bg-light);
  color: var(--fg);
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nii-viewer__mode-button:hover {
  background: var(--border);
}

.nii-viewer__mode-button--active {
  background: var(--fg-dark);
  color: white;
}

.nii-viewer__mode-button--active:hover {
  background: var(--muted);
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@media (max-width: 1023px) {
  .nii-viewer__grid,
  .nii-viewer__skeleton-grid {
    grid-template-columns: 1fr;
  }
}

```

已将 Query Builder 和 NIfTI Viewer 的标题文字放大：

## 完成的修改：

1. **Query Builder 标题**：
   - 在 `Card.css` 中将 `.card__title` 的字体大小从 `16px` 增加到 `20px`
   - 这会同时影响 Query Builder 和 Studies 标题

2. **NIfTI Viewer 标题**：
   - 在 `NiiViewer.css` 中将 `.nii-viewer__title` 的字体大小从 `16px` 增加到 `20px`

两个标题现在都使用 20px 字体大小。修改完成，没有 lint 错误。

